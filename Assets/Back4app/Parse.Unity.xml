<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Parse.Unity</name>
    </assembly>
    <members>
        <member name="T:System.IProgress`1">
            <summary>
            An interface for handlers of progress update notifications.
            </summary>
            <typeparam name="T">The type of progress notifications that will be sent.</typeparam>
        </member>
        <member name="M:System.IProgress`1.Report(`0)">
            <summary>
            Reports a change in progress to the handler.
            </summary>
            <param name="value">The new progress value.</param>
        </member>
        <member name="T:System.Progress`1">
            <summary>
            Provides a convenient <see cref="T:System.IProgress`1"/> implementation for 
            handling progress update notifications.
            </summary>
            <typeparam name="T">The progress event argument type.</typeparam>
        </member>
        <member name="M:System.Progress`1.#ctor">
            <summary>
            Constructs a new Progress handler.
            </summary>
        </member>
        <member name="M:System.Progress`1.#ctor(System.Action{`0})">
            <summary>
            Constructs a new Progress handler that will invoke the given action when
            progress events are raised.
            </summary>
            <param name="handler">The action to invoke when progress changes.</param>
        </member>
        <member name="M:System.Progress`1.OnReport(`0)">
            <summary>
            A method that is called whenever progress events are raised. Override
            this method to handle the event.
            </summary>
            <param name="value">The updated progress.</param>
        </member>
        <member name="E:System.Progress`1.ProgressChanged">
            <summary>
            An event that is raised whenever progress changes are reported.
            </summary>
        </member>
        <member name="T:System.TypeExtensions">
             <summary>
             Unity does not have an API for GetTypeInfo(), instead they expose most of the methods
             on System.Reflection.TypeInfo on the type itself. This poses a problem for compatibility
             with the rest of the C# world, as we expect the result of GetTypeInfo() to be an actual TypeInfo,
             as well as be able to be converted back to a type using AsType().
            
             This class simply implements some of the simple missing methods on Type to make it as API-compatible
             as possible to TypeInfo.
             </summary>
        </member>
        <member name="T:System.AggregateException">
            <summary>
            Aggregates Exceptions that may be thrown in the process of a task's execution.
            </summary>
        </member>
        <member name="M:System.AggregateException.#ctor(System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            Creates a new AggregateException from a collection of exceptions.
            </summary>
            <param name="innerExceptions">The inner exceptions.</param>
        </member>
        <member name="M:System.AggregateException.Flatten">
            <summary>
            Flattens any nested AggregateExceptions into a single AggregateException
            whose InnerExceptions include the Exceptions of its children.
            </summary>
            <returns>A new AggregateException with no inner AggregateExceptions.</returns>
        </member>
        <member name="M:System.AggregateException.ToString">
            <summary>
            Provides a summary of this Exception and all of its InnerExceptions.
            </summary>
            <returns>A string representation of this AggregateException.</returns>
        </member>
        <member name="P:System.AggregateException.InnerExceptions">
            <summary>
            Gets the exceptions that caused this AggregateException to be raised.
            </summary>
        </member>
        <member name="T:System.Threading.CancellationToken">
            <summary>
            A token that can be used for cancellation of an asynchronous operation.
            </summary>
        </member>
        <member name="M:System.Threading.CancellationToken.Register(System.Action)">
            <summary>
            Registers a callback to be invoked when this CancellationToken is cancelled.
            </summary>
            <param name="callback">The action to be invoked.</param>
            <returns>A registration object that can be used to deregister the callback.</returns>
        </member>
        <member name="M:System.Threading.CancellationToken.ThrowIfCancellationRequested">
            <summary>
            Throws an OperationCanceledException if the token has been cancelled.
            </summary>
        </member>
        <member name="P:System.Threading.CancellationToken.None">
            <summary>
            Gets an empty CancellationToken that cannot be cancelled.
            </summary>
        </member>
        <member name="P:System.Threading.CancellationToken.IsCancellationRequested">
            <summary>
            Gets whether cancellation has been requested for this token.
            </summary>
        </member>
        <member name="T:System.Threading.CancellationTokenRegistration">
            <summary>
            Represents a registration of a handler with a cancellation token, and can be used to
            unregister that handler.
            </summary>
        </member>
        <member name="M:System.Threading.CancellationTokenRegistration.Dispose">
            <summary>
            Unregisters the handler associated with this registration.
            </summary>
        </member>
        <member name="T:System.Threading.CancellationTokenSource">
            <summary>
            A provider for <see cref="T:System.Threading.CancellationToken"/>s. Use the CancellationTokenSource to
            notify consumers of its token that they should cancel any ongoing operations.
            </summary>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.Cancel">
            <summary>
            Notifies consumers of the token that cancellation was requested.
            </summary>
        </member>
        <member name="M:System.Threading.CancellationTokenSource.Cancel(System.Boolean)">
            <summary>
            Notifies consumers of the token that cancellation was requested.
            If <paramref name="throwOnFirstException"/> is true, any exception thrown by a
            handler of the cancellation request will cause processing of the cancellation
            to halt and the exception will propagate immediately to the caller.
            </summary>
            <param name="throwOnFirstException">Whether to throw on first exception.</param>
        </member>
        <member name="P:System.Threading.CancellationTokenSource.Token">
            <summary>
            Gets a cancellation token linked to this CancellationTokenSource.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.Task">
            <summary>
            Represents an asynchronous task.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.Wait">
            <summary>
            Blocks until the task is complete.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})">
            <summary>
            Registers a continuation for the task that will run when the task is complete.
            </summary>
            <typeparam name="T">The type returned by the continuation.</typeparam>
            <param name="continuation">The continuation to run after the task completes.
            The function takes the completed task as an argument and can return a value.</param>
            <returns>A new Task that returns the value returned by the continuation after both
            the task and the continuation are complete.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
            <summary>
            Registers a continuation for the task that will run when the task is complete.
            </summary>
            <typeparam name="T">The type returned by the continuation.</typeparam>
            <param name="continuation">The continuation to run after the task completes.
            The function takes the completed task as an argument and can return a value.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A new Task that returns the value returned by the continuation after both
            the task and the continuation are complete.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})">
            <summary>
            Registers a continuation for the task that will run when the task is complete.
            </summary>
            <param name="continuation">The continuation to run after the task completes.
            The function takes the completed task as an argument.</param>
            <returns>A new Task that is complete after both the task and the continuation are
            complete.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Registers a continuation for the task that will run when the task is complete.
            </summary>
            <param name="continuation">The continuation to run after the task completes.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A new Task that is complete after both the task and the continuation are
            complete.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])">
            <summary>
            Creates a task that is complete when all of the provided tasks are complete.
            If any of the tasks has an exception, all exceptions raised in the tasks will
            be aggregated into the returned task. Otherwise, if any of the tasks is cancelled,
            the returned task will be cancelled.
            </summary>
            <param name="tasks">The tasks to aggregate.</param>
            <returns>A task that is complete when all of the provided tasks are complete.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <summary>
            Creates a task that is complete when all of the provided tasks are complete.
            If any of the tasks has an exception, all exceptions raised in the tasks will
            be aggregated into the returned task. Otherwise, if any of the tasks is cancelled,
            the returned task will be cancelled.
            </summary>
            <param name="tasks">The tasks to aggregate.</param>
            <returns>A task that is complete when all of the provided tasks are complete.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})">
            <summary>
            Creates a task that is complete when all of the provided tasks are complete.
            If any of the tasks has an exception, all exceptions raised in the tasks will
            be aggregated into the returned task. Otherwise, if any of the tasks is cancelled,
            the returned task will be cancelled. If all of the tasks succeed, the result of the
            returned task will be an array containing the results of all of the input tasks.
            </summary>
            <typeparam name="T">The result type of the tasks.</typeparam>
            <param name="tasks">The tasks to aggregate.</param>
            <returns>A task that is complete when all of the provided tasks are complete.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.FromResult``1(``0)">
            <summary>
            Creates a new, completed task for the given result.
            </summary>
            <typeparam name="T">The result type of the task.</typeparam>
            <param name="result"></param>
            <returns>A completed task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})">
            <summary>
            Executes a function asynchronously, returning a task that represents the operation.
            </summary>
            <typeparam name="T">The return type of the task.</typeparam>
            <param name="toRun">The function to run.</param>
            <returns>A task representing the asynchronous operation.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.Run(System.Action)">
            <summary>
            Executes an action asynchronously, returning a task that represents the operation.
            </summary>
            <param name="toRun">The action to run.</param>
            <returns>A task representing the asynchronous operation.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)">
            <summary>
            Creates a task that will complete successfully after the given timespan.
            </summary>
            <param name="timespan">The amount of time to wait.</param>
            <returns>A new task.</returns>
        </member>
        <member name="P:System.Threading.Tasks.Task.Exception">
            <summary>
            Gets the exceptions for the task, if there are any. <c>null</c> otherwise.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsCanceled">
            <summary>
            Gets whether the task was cancelled.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsCompleted">
            <summary>
            Gets whether the task has been completed with either an exception,
            cancellation, or a result.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.Task.IsFaulted">
            <summary>
            Gets whether the task failed.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.Task`1">
            <summary>
            Represents an asynchronous task that has a result.
            </summary>
            <typeparam name="T">The type of the task's result.</typeparam>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})">
            <summary>
            Registers a continuation for the task that will run when the task is complete.
            </summary>
            <param name="continuation">The continuation to run after the task completes.
            The function takes the completed task as an argument.</param>
            <returns>A new Task that is complete after both the task and the continuation are
            complete.</returns>
        </member>
        <member name="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0})">
            <summary>
            Registers a continuation for the task that will run when the task is complete.
            </summary>
            <typeparam name="TResult">The type returned by the continuation.</typeparam>
            <param name="continuation">The continuation to run after the task completes.
            The function takes the completed task as an argument and can return a value.</param>
            <returns>A new Task that returns the value returned by the continuation after both
            the task and the continuation are complete.</returns>
        </member>
        <member name="P:System.Threading.Tasks.Task`1.Result">
            <summary>
            Gets the result of the task. If the task is not complete, this property blocks
            until the task is complete. If the task has an Exception or was cancelled, this
            property will rethrow the exception.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.TaskCompletionSource`1">
            <summary>
            Allows safe orchestration of a task's completion, preventing the consumer from prematurely
            completing the task. Essentially, it represents the producer side of a <see cref="T:System.Threading.Tasks.Task`1"/>,
            providing access to the consumer side through the <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task"/>
            while isolating the Task's completion mechanisms from the consumer.
            </summary>
            <typeparam name="T">The type of the result of the Task being created.</typeparam>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.#ctor">
            <summary>
            Constructs a new TaskCompletionSource.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetResult(`0)">
            <summary>
            If the task is not already complete, completes the task by setting the result.
            </summary>
            <param name="result">The result for the task.</param>
            <returns><c>true</c> if the result was set successfully.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.AggregateException)">
            <summary>
            If the task is not already complete, completes the task by setting the exception.
            </summary>
            <param name="exception">The exception for the task.</param>
            <returns><c>true</c> if the exception was set successfully.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetException(System.Exception)">
            <summary>
            If the task is not already complete, completes the task by setting the exception.
            </summary>
            <param name="exception">The exception for the task.</param>
            <returns><c>true</c> if the exception was set successfully.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.TrySetCanceled">
            <summary>
            If the task is not already complete, cancels the task.
            </summary>
            <returns><c>true</c> if the task was successfully cancelled.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.SetResult(`0)">
            <summary>
            Completes the task by setting the result. Throws an <see cref="T:System.InvalidOperationException"/>
            if the task is already complete.
            </summary>
            <param name="result">The result for the task.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.AggregateException)">
            <summary>
            Completes the task by setting the exception. Throws an
            <see cref="T:System.InvalidOperationException"/> if the task is already complete.
            </summary>
            <param name="exception">The exception for the task.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.SetException(System.Exception)">
            <summary>
            Completes the task by setting the exception. Throws an
            <see cref="T:System.InvalidOperationException"/> if the task is already complete.
            </summary>
            <param name="exception">The exception for the task.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSource`1.SetCanceled">
            <summary>
            Cancels the task. Throws an <see cref="T:System.InvalidOperationException"/> if the task is
            already complete.
            </summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskCompletionSource`1.Task">
            <summary>
            Gets the task associated with this TaskCompletionSource.
            </summary>
        </member>
        <member name="T:System.Threading.Tasks.TaskExtensions">
            <summary>
            Provides extension methods for working with <see cref="T:System.Threading.Tasks.Task"/>s.
            </summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskExtensions.Unwrap(System.Threading.Tasks.Task{System.Threading.Tasks.Task})">
            <summary>
            Unwraps a nested task, producing a task that is complete when both the outer
            and inner tasks are complete. This is primarily useful for chaining asynchronous
            operations together.
            </summary>
            <param name="task">The task to unwrap.</param>
            <returns>A new task that is complete when both the outer and inner tasks
            are complete.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskExtensions.Unwrap``1(System.Threading.Tasks.Task{System.Threading.Tasks.Task{``0}})">
            <summary>
            Unwraps a nested task, producing a task that is complete when both the outer
            and inner tasks are complete and that has the inner task's result.
            This is primarily useful for chaining asynchronous operations together.
            </summary>
            <param name="task">The task to unwrap.</param>
            <returns>A new task that is complete when both the outer and inner tasks
            are complete and that has the inner task's result.</returns>
        </member>
        <member name="M:Parse.Internal.IParseAuthenticationProvider.AuthenticateAsync(System.Threading.CancellationToken)">
            <summary>
            Authenticates with the service.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.Internal.IParseAuthenticationProvider.Deauthenticate">
            <summary>
            Deauthenticates (logs out) the user associated with this provider. This
            call may block.
            </summary>
        </member>
        <member name="M:Parse.Internal.IParseAuthenticationProvider.RestoreAuthentication(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Restores authentication that has been serialized, such as session keys,
            etc.
            </summary>
            <param name="authData">The auth data for the provider. This value may be null
            when unlinking an account.</param>
            <returns><c>true</c> iff the authData was successfully synchronized. A <c>false</c> return
            value indicates that the user should no longer be associated because of bad auth
            data.</returns>
        </member>
        <member name="P:Parse.Internal.IParseAuthenticationProvider.AuthType">
            <summary>
            Provides a unique name for the type of authentication the provider does.
            For example, the FacebookAuthenticationProvider would return "facebook".
            </summary>
        </member>
        <member name="M:Parse.Internal.FacebookAuthenticationProvider.TryParseOAuthCallbackUrl(System.Uri,System.Collections.Generic.IDictionary{System.String,System.String}@)">
            <summary>
            Parses a uri, looking for a base uri that represents facebook login completion, and then
            converting the query string into a dictionary of key-value pairs. (e.g. access_token)
            </summary>
        </member>
        <member name="M:Parse.Internal.IParseCommandRunner.RunCommandAsync(Parse.Internal.ParseCommand,System.IProgress{Parse.ParseUploadProgressEventArgs},System.IProgress{Parse.ParseDownloadProgressEventArgs},System.Threading.CancellationToken)">
            <summary>
            Executes <see cref="T:Parse.Internal.ParseCommand"/> and convert the result into Dictionary.
            </summary>
            <param name="command">The command to be run.</param>
            <param name="uploadProgress">Upload progress callback.</param>
            <param name="downloadProgress">Download progress callback.</param>
            <param name="cancellationToken">The cancellation token for the request.</param>
            <returns></returns>
        </member>
        <member name="T:Parse.Internal.ParseCommand">
            <summary>
            ParseCommand is an <see cref="T:Parse.Internal.HttpRequest"/> with pre-populated
            headers.
            </summary>
        </member>
        <member name="T:Parse.Internal.HttpRequest">
            <summary>
            <code>IHttpRequest</code> is an interface that provides an API to execute HTTP request data.
            </summary>
        </member>
        <member name="P:Parse.Internal.HttpRequest.Data">
            <summary>
            Data stream to be uploaded.
            </summary>
        </member>
        <member name="P:Parse.Internal.HttpRequest.Method">
            <summary>
            HTTP method. One of <c>DELETE</c>, <c>GET</c>, <c>HEAD</c>, <c>POST</c> or <c>PUT</c>
            </summary>
        </member>
        <member name="M:Parse.Internal.IParseConfigController.FetchConfigAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Fetches the config from the server asynchronously.
            </summary>
            <returns>The config async.</returns>
            <param name="sessionToken">Session token.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="P:Parse.Internal.IParseConfigController.CurrentConfigController">
            <summary>
            Gets the current config controller.
            </summary>
            <value>The current config controller.</value>
        </member>
        <member name="M:Parse.Internal.IParseCurrentConfigController.GetCurrentConfigAsync">
            <summary>
            Gets the current config async.
            </summary>
            <returns>The current config async.</returns>
        </member>
        <member name="M:Parse.Internal.IParseCurrentConfigController.SetCurrentConfigAsync(Parse.ParseConfig)">
            <summary>
            Sets the current config async.
            </summary>
            <returns>The current config async.</returns>
            <param name="config">Config.</param>
        </member>
        <member name="M:Parse.Internal.IParseCurrentConfigController.ClearCurrentConfigAsync">
            <summary>
            Clears the current config async.
            </summary>
            <returns>The current config async.</returns>
        </member>
        <member name="M:Parse.Internal.IParseCurrentConfigController.ClearCurrentConfigInMemoryAsync">
            <summary>
            Clears the current config in memory async.
            </summary>
            <returns>The current config in memory async.</returns>
        </member>
        <member name="T:Parse.Internal.ParseConfigController">
            <summary>
            Config controller.
            </summary>
        </member>
        <member name="M:Parse.Internal.ParseConfigController.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Parse.Internal.ParseConfigController"/> class.
            </summary>
        </member>
        <member name="T:Parse.Internal.ParseCurrentConfigController">
            <summary>
            Parse current config controller.
            </summary>
        </member>
        <member name="M:Parse.Internal.ParseCurrentConfigController.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Parse.Internal.ParseCurrentConfigController"/> class.
            </summary>
        </member>
        <member name="T:Parse.Internal.NoObjectsEncoder">
            <summary>
            A <see cref="T:Parse.Internal.ParseEncoder"/> that throws an exception if it attempts to encode
            a <see cref="T:Parse.ParseObject"/>
            </summary>
        </member>
        <member name="T:Parse.Internal.ParseEncoder">
            <summary>
            A <c>ParseEncoder</c> can be used to transform objects such as <see cref="T:Parse.ParseObject"/> into JSON
            data structures.
            </summary>
            <seealso cref="T:Parse.Internal.ParseDecoder"/>
        </member>
        <member name="T:Parse.Internal.PointerOrLocalIdEncoder">
            <summary>
            A <see cref="T:Parse.Internal.ParseEncoder"/> that encode <see cref="T:Parse.ParseObject"/> as pointers. If the object
            does not have an <see cref="P:Parse.ParseObject.ObjectId"/>, uses a local id.
            </summary>
        </member>
        <member name="M:Parse.Internal.IHttpClient.ExecuteAsync(Parse.Internal.HttpRequest,System.IProgress{Parse.ParseUploadProgressEventArgs},System.IProgress{Parse.ParseDownloadProgressEventArgs},System.Threading.CancellationToken)">
            <summary>
            Executes HTTP request to a <see cref="P:Parse.Internal.HttpRequest.Uri"/> with <see cref="P:Parse.Internal.HttpRequest.Method"/> HTTP verb
            and <see cref="P:Parse.Internal.HttpRequest.Headers"/>.
            </summary>
            <param name="httpRequest">The HTTP request to be executed.</param>
            <param name="uploadProgress">Upload progress callback.</param>
            <param name="downloadProgress">Download progress callback.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A task that resolves to Htt</returns>
        </member>
        <member name="M:Parse.Internal.HttpClient.GetStatusCode(UnityEngine.WWW)">
            <summary>
            Gets the HTTP status code from finished <code>WWW</code> request.
            </summary>
            <param name="www">The WWW object.</param>
            <returns>Returns 201 if there's no error. Otherwise, returns error status code.</returns>
        </member>
        <member name="M:Parse.Internal.HttpClient.GenerateWWWInstance(System.String,System.Byte[],System.Collections.Hashtable)">
            <summary>
            Unity changes its WWW constructor at 4.5.x from using <see cref="T:System.Collections.Hashtable"/> to using
            <see cref="T:System.Collections.Generic.Dictionary`2"/>. We need to explicitly handle that. This method
            generates a valid WWW instance depending on the newest WWW constructor
            provided by used UnityEngine assembly
            </summary>
        </member>
        <member name="M:Parse.Internal.IInstallationIdController.Set(System.Nullable{System.Guid})">
            <summary>
            Sets current <code>installationId</code> and saves it to local storage.
            </summary>
            <param name="installationId">The <code>installationId</code> to be saved.</param>
        </member>
        <member name="M:Parse.Internal.IInstallationIdController.Get">
            <summary>
            Gets current <code>installationId</code> from local storage. Generates a none exists.
            </summary>
            <returns>Current <code>installationId</code>.</returns>
        </member>
        <member name="M:Parse.Internal.IInstallationIdController.Clear">
            <summary>
            Clears current installationId from memory and local storage.
            </summary>
        </member>
        <member name="T:Parse.Internal.IParseObjectCurrentController`1">
            <summary>
            <code>IParseObjectCurrentController</code> controls the single-instance <see cref="T:Parse.ParseObject"/>
            persistence used throughout the code-base. Sample usages are <see cref="P:Parse.ParseUser.CurrentUser"/> and
            <see cref="P:Parse.ParseInstallation.CurrentInstallation"/>.
            </summary>
            <typeparam name="T">Type of object being persisted.</typeparam>
        </member>
        <member name="M:Parse.Internal.IParseObjectCurrentController`1.SetAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Persists current <see cref="T:Parse.ParseObject"/>.
            </summary>
            <param name="obj"><see cref="T:Parse.ParseObject"/> to be persisted.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.Internal.IParseObjectCurrentController`1.GetAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the persisted current <see cref="T:Parse.ParseObject"/>.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.Internal.IParseObjectCurrentController`1.ExistsAsync(System.Threading.CancellationToken)">
            <summary>
            Returns a <see cref="T:System.Threading.Tasks.Task"/> that resolves to <code>true</code> if current
            <see cref="T:Parse.ParseObject"/> exists.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.Internal.IParseObjectCurrentController`1.IsCurrent(`0)">
            <summary>
            Returns <code>true</code> if the given <see cref="T:Parse.ParseObject"/> is the persisted current
            <see cref="T:Parse.ParseObject"/>.
            </summary>
            <param name="obj">The object to check.</param>
            <returns>True if <code>obj</code> is the current persisted <see cref="T:Parse.ParseObject"/>.</returns>
        </member>
        <member name="M:Parse.Internal.IParseObjectCurrentController`1.ClearFromMemory">
            <summary>
            Nullifies the current <see cref="T:Parse.ParseObject"/> from memory.
            </summary>
        </member>
        <member name="M:Parse.Internal.IParseObjectCurrentController`1.ClearFromDisk">
            <summary>
            Clears current <see cref="T:Parse.ParseObject"/> from disk.
            </summary>
        </member>
        <member name="T:Parse.Internal.IParseFieldOperation">
            <summary>
            A ParseFieldOperation represents a modification to a value in a ParseObject.
            For example, setting, deleting, or incrementing a value are all different kinds of
            ParseFieldOperations. ParseFieldOperations themselves can be considered to be
            immutable.
            </summary>
        </member>
        <member name="M:Parse.Internal.IParseFieldOperation.Encode">
            <summary>
            Converts the ParseFieldOperation to a data structure that can be converted to JSON and sent to
            Parse as part of a save operation.
            </summary>
            <returns>An object to be JSONified.</returns>
        </member>
        <member name="M:Parse.Internal.IParseFieldOperation.MergeWithPrevious(Parse.Internal.IParseFieldOperation)">
            <summary>
            Returns a field operation that is composed of a previous operation followed by
            this operation. This will not mutate either operation. However, it may return
            <code>this</code> if the current operation is not affected by previous changes.
            For example:
              {increment by 2}.MergeWithPrevious({set to 5})       -> {set to 7}
                    {set to 5}.MergeWithPrevious({increment by 2}) -> {set to 5}
                   {add "foo"}.MergeWithPrevious({delete})         -> {set to ["foo"]}
                      {delete}.MergeWithPrevious({add "foo"})      -> {delete}        /// </summary>
            <param name="previous">The most recent operation on the field, or null if none.</param>
            <returns>A new ParseFieldOperation or this.</returns>
        </member>
        <member name="M:Parse.Internal.IParseFieldOperation.Apply(System.Object,System.String)">
            <summary>
            Returns a new estimated value based on a previous value and this operation. This
            value is not intended to be sent to Parse, but it is used locally on the client to
            inspect the most likely current value for a field.
            
            The key and object are used solely for ParseRelation to be able to construct objects
            that refer back to their parents.
            </summary>
            <param name="oldValue">The previous value for the field.</param>
            <param name="key">The key that this value is for.</param>
            <returns>The new value for the field.</returns>
        </member>
        <member name="T:Parse.Internal.ParseDeleteOperation">
            <summary>
            An operation where a field is deleted from the object.
            </summary>
        </member>
        <member name="M:Parse.Internal.IPlatformHooks.ExecuteParseInstallationSaveHookAsync(Parse.ParseInstallation)">
            <summary>
            Executes platform specific hook that mutate the installation based on
            the device platforms.
            </summary>
            <param name="installation">Installation to be mutated.</param>
            <returns></returns>
        </member>
        <member name="P:Parse.Internal.IPlatformHooks.ApplicationSettings">
            <summary>
            A thread-safe dictionary that persists key-value pair objects to disk.
            </summary>
        </member>
        <member name="M:Parse.PlatformHooks.CallStaticJavaUnityMethod(System.String,System.String,System.Object[])">
            <summary>
            Calls a static method under Unity Java plugin with reflection.
            </summary>
            <remarks>
            Warning: Unity Android only.
            
            Basically what we want to do:
            <code>
            AndroidJavaClass javaUnityHelper = new AndroidJavaClass(className);
            javaUnityHelper.CallStatic(methodName, parameters);
            But we can't because <c>AndroidJavaClass</c> is not cross-platform. It won't compile on iOS.
            </code>
            </remarks>
            <param name="className"></param>
            <param name="methodName"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Parse.PlatformHooks.CreateWrapperTypes">
            <summary>
            Exists to ensure that generic types are AOT-compiled for the conversions we support.
            Any new value types that we add support for will need to be registered here.
            The method itself is never called, but by virtue of the Preserve attribute being set
            on the PlatformHooks class, these types will be AOT-compiled.
            </summary>
        </member>
        <member name="M:Parse.PlatformHooks.RegisterNetworkRequest(UnityEngine.WWW,System.Action{UnityEngine.WWW})">
            <summary>
            Registers a callback for network requests, running the callback on the main thread until
            the network request is complete.
            </summary>
        </member>
        <member name="M:Parse.PlatformHooks.RegisterDeviceTokenRequest(System.Action{System.Byte[]})">
            <summary>
            Warning: iOS only. Registers a callback for device token request.
            </summary>
            <param name="action">Action to be completed when device token is received.</param>
        </member>
        <member name="M:Parse.PlatformHooks.RegisteriOSPushNotificationListener(System.Action{System.Collections.Generic.IDictionary{System.String,System.Object}})">
            <summary>
            Warning: iOS only. Registers a callback for push notification.
            </summary>
            <param name="action">Action to be completed when push notification is received.</param>
        </member>
        <member name="M:Parse.PlatformHooks.RunOnMainThread(System.Action)">
            <summary>
            Runs things inside of a Unity coroutine (some APIs require that you
            access them from the main thread).
            </summary>
        </member>
        <member name="M:Parse.PlatformHooks.RunDispatcher">
            <summary>
            Returns an enumerator (for use in a coroutine) that runs actions that have been dispatched.
            </summary>
        </member>
        <member name="M:Parse.PlatformHooks.Initialize">
            <summary>
            Initialize the app. Called from <see cref="M:Parse.ParseClient.Initialize(System.String,System.String)"/>. Guaranteed to be run on main thread.
            </summary>
        </member>
        <member name="P:Parse.PlatformHooks.IsCompiledByIL2CPP">
            <summary>
            Returns true if current running platform is run from a project generated by IL2CPP compiler.
            </summary>
        </member>
        <member name="P:Parse.PlatformHooks.IsWebPlayer">
            <summary>
            Returns true if current running platform is a web player.
            </summary>
        </member>
        <member name="P:Parse.PlatformHooks.IsAndroid">
            <summary>
            Returns true if current running platform is Android.
            </summary>
        </member>
        <member name="P:Parse.PlatformHooks.IsIOS">
            <summary>
            Returns true if current running platform is iPhone or iPad. 
            </summary>
        </member>
        <member name="P:Parse.PlatformHooks.IsTvOS">
            <summary>
            Returns true if the current platform is tvOS.
            </summary>
        </member>
        <member name="P:Parse.PlatformHooks.IsWindowsPhone8">
            <summary>
            Returns true if current running platform is Windows Phone 8.
            </summary>
        </member>
        <member name="P:Parse.PlatformHooks.ApplicationSettings">
            <summary>
            Provides a dictionary that gets persisted on the filesystem between runs of the app.
            This is analogous to NSUserDefaults in iOS.
            </summary>
        </member>
        <member name="T:Parse.PlatformHooks.SettingsWrapper">
            <summary>
            Wraps the custom settings object for Parse so that it can be exposed as ApplicationSettings.
            </summary>
        </member>
        <member name="T:Parse.Internal.FlexibleDictionaryWrapper`2">
            <summary>
            Provides a Dictionary implementation that can delegate to any other
            dictionary, regardless of its value type. Used for coercion of
            dictionaries when returning them to users.
            </summary>
            <typeparam name="TOut">The resulting type of value in the dictionary.</typeparam>
            <typeparam name="TIn">The original type of value in the dictionary.</typeparam>
        </member>
        <member name="T:Parse.Internal.FlexibleListWrapper`2">
            <summary>
            Provides a List implementation that can delegate to any other
            list, regardless of its value type. Used for coercion of
            lists when returning them to users.
            </summary>
            <typeparam name="TOut">The resulting type of value in the list.</typeparam>
            <typeparam name="TIn">The original type of value in the list.</typeparam>
        </member>
        <member name="T:Parse.Internal.IdentityEqualityComparer`1">
            <summary>
            An equality comparer that uses the object identity (i.e. ReferenceEquals)
            rather than .Equals, allowing identity to be used for checking equality in
            ISets and IDictionaries.
            </summary>
        </member>
        <member name="T:Parse.Internal.IJsonConvertible">
            <summary>
            Represents an object that can be converted into JSON.
            </summary>
        </member>
        <member name="M:Parse.Internal.IJsonConvertible.ToJSON">
            <summary>
            Converts the object to a data structure that can be converted to JSON.
            </summary>
            <returns>An object to be JSONified.</returns>
        </member>
        <member name="T:Parse.Internal.InternalExtensions">
            <summary>
            Provides helper methods that allow us to use terser code elsewhere.
            </summary>
        </member>
        <member name="M:Parse.Internal.InternalExtensions.Safe``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Ensures a task (even null) is awaitable.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:Parse.Internal.InternalExtensions.Safe(System.Threading.Tasks.Task)">
            <summary>
            Ensures a task (even null) is awaitable.
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:Parse.Internal.InternalExtensions.GetPartial``1(Parse.ParseObject,Parse.Internal.InternalExtensions.PartialAccessor{``0})">
            <summary>
            Partial methods cannot return a value, so we instead make partial accessors
            use ref params. This helper can be used to write code more normally so we get
            the out-param or default when calling a partial method. Given a partial method:
            partial void GetFoo(ref string foo)
            we can say string foo = this.GetPartial&lt;string&gt;(GetFoo);
            </summary>
            <typeparam name="T"></typeparam>
            <param name="self"></param>
            <param name="action"></param>
        </member>
        <member name="M:Parse.Internal.InternalExtensions.PartialAsync``1(System.Object,Parse.Internal.InternalExtensions.PartialAccessor{System.Threading.Tasks.Task{``0}})">
            <summary>
            Partial methods cannot return a value, so we instead make partial accessors
            use ref params. This means you cannot effectively make a partial which is
            async. This code helps create a design pattern where a partial takes a ref Task
            param and we can await the PartialAsync of it. Given a partial method:
            partial void FooAsync(ref Task&lt;string&gt; task)
            we can say string foo = await PartialAsync&lt;string&gt;(FooAsync);
            </summary>
            <typeparam name="T"></typeparam>
            <param name="self"></param>
            <param name="partial"></param>
            <returns></returns>
        </member>
        <member name="T:Parse.Internal.Json">
            <summary>
            A simple recursive-descent JSON Parser based on the grammar defined at http://www.json.org
            and http://tools.ietf.org/html/rfc4627
            </summary>
        </member>
        <member name="F:Parse.Internal.Json.startOfString">
            <summary>
            Place at the start of a regex to force the match to begin wherever the search starts (i.e.
            anchored at the index of the first character of the search, even when that search starts
            in the middle of the string).
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.Parse(System.String)">
            <summary>
            Parses a JSON-text as defined in http://tools.ietf.org/html/rfc4627, returning an
            IDictionary&lt;string, object&gt; or an IList&lt;object&gt; depending on whether
            the value was an array or dictionary. Nested objects also match these types.
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.Encode(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Encodes a dictionary into a JSON string. Supports values that are
            IDictionary&lt;string, object&gt;, IList&lt;object&gt;, strings,
            nulls, and any of the primitive types.
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.Encode(System.Collections.Generic.IList{System.Object})">
            <summary>
            Encodes a list into a JSON string. Supports values that are
            IDictionary&lt;string, object&gt;, IList&lt;object&gt;, strings,
            nulls, and any of the primitive types.
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.Encode(System.Object)">
            <summary>
            Encodes an object into a JSON string.
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.JsonStringParser.ParseObject(System.Object@)">
            <summary>
            Parses JSON object syntax (e.g. '{}')
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.JsonStringParser.ParseMember(System.Object@)">
            <summary>
            Parses JSON member syntax (e.g. '"keyname" : null')
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.JsonStringParser.ParseArray(System.Object@)">
            <summary>
            Parses JSON array syntax (e.g. '[]')
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.JsonStringParser.ParseValue(System.Object@)">
            <summary>
            Parses a value (i.e. the right-hand side of an object member assignment or
            an element in an array)
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.JsonStringParser.ParseString(System.Object@)">
            <summary>
            Parses a JSON string (e.g. '"foo\u1234bar\n"')
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.JsonStringParser.ParseNumber(System.Object@)">
            <summary>
            Parses a number. Returns a long if the number is an integer or has an exponent,
            otherwise returns a double.
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.JsonStringParser.Accept(System.Text.RegularExpressions.Regex,System.Text.RegularExpressions.Match@)">
            <summary>
            Matches the string to a regex, consuming part of the string and returning the match.
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.JsonStringParser.Accept(System.Char)">
            <summary>
            Find the first occurrences of a character, consuming part of the string.
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.JsonStringParser.Accept(System.Char[])">
            <summary>
            Find the first occurrences of a string, consuming part of the string.
            </summary>
        </member>
        <member name="M:Parse.Internal.ReflectionHelpers.FindConstructor(System.Type,System.Type[])">
            <summary>
            This method helps simplify the process of getting a constructor for a type.
            A method like this exists in .NET but is not allowed in a Portable Class Library,
            so we've built our own.
            </summary>
            <param name="self"></param>
            <param name="parameterTypes"></param>
            <returns></returns>
        </member>
        <member name="T:Parse.Internal.SynchronizedEventHandler`1">
            <summary>
            Represents an event handler that calls back from the synchronization context
            that subscribed.
            <typeparam name="T">Should look like an EventArgs, but may not inherit EventArgs if T is implemented by the Windows team.</typeparam>
            </summary>
        </member>
        <member name="T:Parse.Internal.TaskQueue">
            <summary>
            A helper class for enqueuing tasks
            </summary>
        </member>
        <member name="F:Parse.Internal.TaskQueue.tail">
            <summary>
            We only need to keep the tail of the queue. Cancelled tasks will
            just complete normally/immediately when their turn arrives.
            </summary>
        </member>
        <member name="M:Parse.Internal.TaskQueue.GetTaskToAwait(System.Threading.CancellationToken)">
            <summary>
            Gets a cancellable task that can be safely awaited and is dependent
            on the current tail of the queue. This essentially gives us a proxy
            for the tail end of the queue whose awaiting can be cancelled.
            </summary>
            <param name="cancellationToken">A cancellation token that cancels
            the task even if the task is still in the queue. This allows the
            running task to return immediately without breaking the dependency
            chain. It also ensures that errors do not propagate.</param>
            <returns>A new task that should be awaited by enqueued tasks.</returns>
        </member>
        <member name="M:Parse.Internal.TaskQueue.Enqueue``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
            <summary>
            Enqueues a task created by <paramref name="taskStart"/>. If the task is
            cancellable (or should be able to be cancelled while it is waiting in the
            queue), pass a cancellationToken.
            </summary>
            <typeparam name="T">The type of task.</typeparam>
            <param name="taskStart">A function given a task to await once state is
            snapshotted (e.g. after capturing session tokens at the time of the save call).
            Awaiting this task will wait for the created task's turn in the queue.</param>
            <param name="cancellationToken">A cancellation token that can be used to
            cancel waiting in the queue.</param>
            <returns>The task created by the taskStart function.</returns>
        </member>
        <member name="T:Parse.ParseACL">
            <summary>
            A ParseACL is used to control which users and roles can access or modify a particular object. Each
            <see cref="T:Parse.ParseObject"/> can have its own ParseACL. You can grant read and write permissions
            separately to specific users, to groups of users that belong to roles, or you can grant permissions
            to "the public" so that, for example, any user could read a particular object but only a particular
            set of users could write to that object.
            </summary>
        </member>
        <member name="M:Parse.ParseACL.#ctor">
            <summary>
            Creates an ACL with no permissions granted.
            </summary>
        </member>
        <member name="M:Parse.ParseACL.#ctor(Parse.ParseUser)">
            <summary>
            Creates an ACL where only the provided user has access.
            </summary>
            <param name="owner">The only user that can read or write objects governed by this ACL.</param>
        </member>
        <member name="M:Parse.ParseACL.SetReadAccess(System.String,System.Boolean)">
            <summary>
            Sets whether the given user id is allowed to read this object.
            </summary>
            <param name="userId">The objectId of the user.</param>
            <param name="allowed">Whether the user has permission.</param>
        </member>
        <member name="M:Parse.ParseACL.SetReadAccess(Parse.ParseUser,System.Boolean)">
            <summary>
            Sets whether the given user is allowed to read this object.
            </summary>
            <param name="user">The user.</param>
            <param name="allowed">Whether the user has permission.</param>
        </member>
        <member name="M:Parse.ParseACL.SetWriteAccess(System.String,System.Boolean)">
            <summary>
            Sets whether the given user id is allowed to write this object.
            </summary>
            <param name="userId">The objectId of the user.</param>
            <param name="allowed">Whether the user has permission.</param>
        </member>
        <member name="M:Parse.ParseACL.SetWriteAccess(Parse.ParseUser,System.Boolean)">
            <summary>
            Sets whether the given user is allowed to write this object.
            </summary>
            <param name="user">The user.</param>
            <param name="allowed">Whether the user has permission.</param>
        </member>
        <member name="M:Parse.ParseACL.GetReadAccess(System.String)">
            <summary>
            Gets whether the given user id is *explicitly* allowed to read this object.
            Even if this returns false, the user may still be able to read it if
            PublicReadAccess is true or a role that the user belongs to has read access.
            </summary>
            <param name="userId">The user objectId to check.</param>
            <returns>Whether the user has access.</returns>
        </member>
        <member name="M:Parse.ParseACL.GetReadAccess(Parse.ParseUser)">
            <summary>
            Gets whether the given user is *explicitly* allowed to read this object.
            Even if this returns false, the user may still be able to read it if
            PublicReadAccess is true or a role that the user belongs to has read access.
            </summary>
            <param name="user">The user to check.</param>
            <returns>Whether the user has access.</returns>
        </member>
        <member name="M:Parse.ParseACL.GetWriteAccess(System.String)">
            <summary>
            Gets whether the given user id is *explicitly* allowed to write this object.
            Even if this returns false, the user may still be able to write it if
            PublicReadAccess is true or a role that the user belongs to has write access.
            </summary>
            <param name="userId">The user objectId to check.</param>
            <returns>Whether the user has access.</returns>
        </member>
        <member name="M:Parse.ParseACL.GetWriteAccess(Parse.ParseUser)">
            <summary>
            Gets whether the given user is *explicitly* allowed to write this object.
            Even if this returns false, the user may still be able to write it if
            PublicReadAccess is true or a role that the user belongs to has write access.
            </summary>
            <param name="user">The user to check.</param>
            <returns>Whether the user has access.</returns>
        </member>
        <member name="M:Parse.ParseACL.SetRoleReadAccess(System.String,System.Boolean)">
            <summary>
            Sets whether users belonging to the role with the given <paramref name="roleName"/>
            are allowed to read this object.
            </summary>
            <param name="roleName">The name of the role.</param>
            <param name="allowed">Whether the role has access.</param>
        </member>
        <member name="M:Parse.ParseACL.SetRoleReadAccess(Parse.ParseRole,System.Boolean)">
            <summary>
            Sets whether users belonging to the given role are allowed to read this object.
            </summary>
            <param name="role">The role.</param>
            <param name="allowed">Whether the role has access.</param>
        </member>
        <member name="M:Parse.ParseACL.GetRoleReadAccess(System.String)">
            <summary>
            Gets whether users belonging to the role with the given <paramref name="roleName"/>
            are allowed to read this object. Even if this returns false, the role may still be
            able to read it if a parent role has read access.
            </summary>
            <param name="roleName">The name of the role.</param>
            <returns>Whether the role has access.</returns>
        </member>
        <member name="M:Parse.ParseACL.GetRoleReadAccess(Parse.ParseRole)">
            <summary>
            Gets whether users belonging to the role are allowed to read this object.
            Even if this returns false, the role may still be able to read it if a
            parent role has read access.
            </summary>
            <param name="role">The name of the role.</param>
            <returns>Whether the role has access.</returns>
        </member>
        <member name="M:Parse.ParseACL.SetRoleWriteAccess(System.String,System.Boolean)">
            <summary>
            Sets whether users belonging to the role with the given <paramref name="roleName"/>
            are allowed to write this object.
            </summary>
            <param name="roleName">The name of the role.</param>
            <param name="allowed">Whether the role has access.</param>
        </member>
        <member name="M:Parse.ParseACL.SetRoleWriteAccess(Parse.ParseRole,System.Boolean)">
            <summary>
            Sets whether users belonging to the given role are allowed to write this object.
            </summary>
            <param name="role">The role.</param>
            <param name="allowed">Whether the role has access.</param>
        </member>
        <member name="M:Parse.ParseACL.GetRoleWriteAccess(System.String)">
            <summary>
            Gets whether users belonging to the role with the given <paramref name="roleName"/>
            are allowed to write this object. Even if this returns false, the role may still be
            able to write it if a parent role has write access.
            </summary>
            <param name="roleName">The name of the role.</param>
            <returns>Whether the role has access.</returns>
        </member>
        <member name="M:Parse.ParseACL.GetRoleWriteAccess(Parse.ParseRole)">
            <summary>
            Gets whether users belonging to the role are allowed to write this object.
            Even if this returns false, the role may still be able to write it if a
            parent role has write access.
            </summary>
            <param name="role">The name of the role.</param>
            <returns>Whether the role has access.</returns>
        </member>
        <member name="P:Parse.ParseACL.PublicReadAccess">
            <summary>
            Gets or sets whether the public is allowed to read this object.
            </summary>
        </member>
        <member name="P:Parse.ParseACL.PublicWriteAccess">
            <summary>
            Gets or sets whether the public is allowed to write this object.
            </summary>
        </member>
        <member name="T:Parse.ParseClassNameAttribute">
            <summary>
            Defines the class name for a subclass of ParseObject.
            </summary>
        </member>
        <member name="M:Parse.ParseClassNameAttribute.#ctor(System.String)">
            <summary>
            Constructs a new ParseClassName attribute.
            </summary>
            <param name="className">The class name to associate with the ParseObject subclass.</param>
        </member>
        <member name="P:Parse.ParseClassNameAttribute.ClassName">
            <summary>
            Gets the class name to associate with the ParseObject subclass.
            </summary>
        </member>
        <member name="T:Parse.ParseClient">
            <summary>
            ParseClient contains static functions that handle global
            configuration for the Parse library.
            </summary>
        </member>
        <member name="M:Parse.ParseClient.Initialize(System.String,System.String)">
            <summary>
            Authenticates this client as belonging to your application. This must be
            called before your application can use the Parse library. The recommended
            way is to put a call to <c>ParseFramework.Initialize</c> in your
            Application startup.
            </summary>
            <param name="applicationId">The Application ID provided in the Parse dashboard.
            </param>
            <param name="dotnetKey">The .NET API Key provided in the Parse dashboard.
            </param>
        </member>
        <member name="M:Parse.ParseClient.Initialize(Parse.ParseClient.Configuration)">
            <summary>
            Authenticates this client as belonging to your application. This must be
            called before your application can use the Parse library. The recommended
            way is to put a call to <c>ParseFramework.Initialize</c> in your
            Application startup.
            </summary>
            <param name="configuration">The configuration to initialize Parse with.
            </param>
        </member>
        <member name="P:Parse.ParseClient.CurrentConfiguration">
            <summary>
            The current configuration that parse has been initialized with.
            </summary>
        </member>
        <member name="T:Parse.ParseClient.Configuration">
            <summary>
            Represents the configuration of the Parse SDK.
            </summary>
        </member>
        <member name="P:Parse.ParseClient.Configuration.ApplicationId">
            <summary>
            The Parse.com application ID of your app.
            </summary>
        </member>
        <member name="P:Parse.ParseClient.Configuration.Server">
            <summary>
            The Parse.com API server to connect to.
            
            Only needs to be set if you're using another server than https://api.parse.com/1.
            </summary>
        </member>
        <member name="P:Parse.ParseClient.Configuration.WindowsKey">
            <summary>
            The Parse.com .NET key for your app.
            </summary>
        </member>
        <member name="T:Parse.ParseCloud">
            <summary>
            The ParseCloud class provides methods for interacting with Parse Cloud Functions.
            </summary>
            <example>
            For example, this sample code calls the
            "validateGame" Cloud Function and calls processResponse if the call succeeded
            and handleError if it failed.
            
            <code>
            var result =
                await ParseCloud.CallFunctionAsync&lt;IDictionary&lt;string, object&gt;&gt;("validateGame", parameters);
            </code>
            </example>
        </member>
        <member name="M:Parse.ParseCloud.CallFunctionAsync``1(System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Calls a cloud function.
            </summary>
            <typeparam name="T">The type of data you will receive from the cloud function. This
            can be an IDictionary, string, IList, ParseObject, or any other type supported by
            ParseObject.</typeparam>
            <param name="name">The cloud function to call.</param>
            <param name="parameters">The parameters to send to the cloud function. This
            dictionary can contain anything that could be passed into a ParseObject except for
            ParseObjects themselves.</param>
            <returns>The result of the cloud call.</returns>
        </member>
        <member name="M:Parse.ParseCloud.CallFunctionAsync``1(System.String,System.Collections.Generic.IDictionary{System.String,System.Object},System.Threading.CancellationToken)">
            <summary>
            Calls a cloud function.
            </summary>
            <typeparam name="T">The type of data you will receive from the cloud function. This
            can be an IDictionary, string, IList, ParseObject, or any other type supported by
            ParseObject.</typeparam>
            <param name="name">The cloud function to call.</param>
            <param name="parameters">The parameters to send to the cloud function. This
            dictionary can contain anything that could be passed into a ParseObject except for
            ParseObjects themselves.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The result of the cloud call.</returns>
        </member>
        <member name="T:Parse.ParseConfig">
            <summary>
            The ParseConfig is a representation of the remote configuration object,
            that enables you to add things like feature gating, a/b testing or simple "Message of the day".
            </summary>
        </member>
        <member name="M:Parse.ParseConfig.GetAsync">
            <summary>
            Retrieves the ParseConfig asynchronously from the server.
            </summary>
            <returns>ParseConfig object that was fetched</returns>
        </member>
        <member name="M:Parse.ParseConfig.GetAsync(System.Threading.CancellationToken)">
            <summary>
            Retrieves the ParseConfig asynchronously from the server.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>ParseConfig object that was fetched</returns>
        </member>
        <member name="M:Parse.ParseConfig.Get``1(System.String)">
            <summary>
            Gets a value for the key of a particular type.
            </summary>
            <typeparam name="T">The type to convert the value to. Supported types are
            ParseObject and its descendents, Parse types such as ParseRelation and ParseGeopoint,
            primitive types,IList&lt;T&gt;, IDictionary&lt;string, T&gt; and strings.</typeparam>
            <param name="key">The key of the element to get.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved
            and <paramref name="key"/> is not found.</exception>
            <exception cref="T:System.FormatException">The property under this <paramref name="key"/>
            key was found, but of a different type.</exception>
        </member>
        <member name="M:Parse.ParseConfig.TryGetValue``1(System.String,``0@)">
            <summary>
            Populates result with the value for the key, if possible.
            </summary>
            <typeparam name="T">The desired type for the value.</typeparam>
            <param name="key">The key to retrieve a value for.</param>
            <param name="result">The value for the given key, converted to the
            requested type, or null if unsuccessful.</param>
            <returns>true if the lookup and conversion succeeded, otherwise false.</returns>
        </member>
        <member name="P:Parse.ParseConfig.CurrentConfig">
            <summary>
            Gets the latest fetched ParseConfig.
            </summary>
            <returns>ParseConfig object</returns>
        </member>
        <member name="P:Parse.ParseConfig.Item(System.String)">
            <summary>
            Gets a value on the config.
            </summary>
            <param name="key">The key for the parameter.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is
            retrieved and <paramref name="key"/> is not found.</exception>
            <returns>The value for the key.</returns>
        </member>
        <member name="T:Parse.ParseDownloadProgressEventArgs">
            <summary>
            Represents download progress.
            </summary>
        </member>
        <member name="P:Parse.ParseDownloadProgressEventArgs.Progress">
            <summary>
            Gets the progress (a number between 0.0 and 1.0) of a download.
            </summary>
        </member>
        <member name="T:Parse.ParseException">
            <summary>
            Exceptions that may occur when sending requests to Parse.
            </summary>
        </member>
        <member name="P:Parse.ParseException.Code">
            <summary>
            The Parse error code associated with the exception.
            </summary>
        </member>
        <member name="T:Parse.ParseException.ErrorCode">
            <summary>
            Error codes that may be delivered in response to requests to Parse.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.OtherCause">
            <summary>
            Error code indicating that an unknown error or an error unrelated to Parse
            occurred.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InternalServerError">
            <summary>
            Error code indicating that something has gone wrong with the server.
            If you get this error code, it is Parse's fault. Please report the bug to
            https://parse.com/help.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.ConnectionFailed">
            <summary>
            Error code indicating the connection to the Parse servers failed.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.ObjectNotFound">
            <summary>
            Error code indicating the specified object doesn't exist.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidQuery">
            <summary>
            Error code indicating you tried to query with a datatype that doesn't
            support it, like exact matching an array or object.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidClassName">
            <summary>
            Error code indicating a missing or invalid classname. Classnames are
            case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the
            only valid characters.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.MissingObjectId">
            <summary>
            Error code indicating an unspecified object id.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidKeyName">
            <summary>
            Error code indicating an invalid key name. Keys are case-sensitive. They
            must start with a letter, and a-zA-Z0-9_ are the only valid characters.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidPointer">
            <summary>
            Error code indicating a malformed pointer. You should not see this unless
            you have been mucking about changing internal Parse code.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidJSON">
            <summary>
            Error code indicating that badly formed JSON was received upstream. This
            either indicates you have done something unusual with modifying how
            things encode to JSON, or the network is failing badly.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.CommandUnavailable">
            <summary>
            Error code indicating that the feature you tried to access is only
            available internally for testing purposes.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.NotInitialized">
            <summary>
            You must call Parse.initialize before using the Parse library.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.IncorrectType">
            <summary>
            Error code indicating that a field was set to an inconsistent type.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidChannelName">
            <summary>
            Error code indicating an invalid channel name. A channel name is either
            an empty string (the broadcast channel) or contains only a-zA-Z0-9_
            characters and starts with a letter.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.PushMisconfigured">
            <summary>
            Error code indicating that push is misconfigured.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.ObjectTooLarge">
            <summary>
            Error code indicating that the object is too large.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.OperationForbidden">
            <summary>
            Error code indicating that the operation isn't allowed for clients.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.CacheMiss">
            <summary>
            Error code indicating the result was not found in the cache.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidNestedKey">
            <summary>
            Error code indicating that an invalid key was used in a nested
            JSONObject.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidFileName">
            <summary>
            Error code indicating that an invalid filename was used for ParseFile.
            A valid file name contains only a-zA-Z0-9_. characters and is between 1
            and 128 characters.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidACL">
            <summary>
            Error code indicating an invalid ACL was provided.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.Timeout">
            <summary>
            Error code indicating that the request timed out on the server. Typically
            this indicates that the request is too expensive to run.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidEmailAddress">
            <summary>
            Error code indicating that the email address was invalid.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.DuplicateValue">
            <summary>
            Error code indicating that a unique field was given a value that is
            already taken.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidRoleName">
            <summary>
            Error code indicating that a role's name is invalid.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.ExceededQuota">
            <summary>
            Error code indicating that an application quota was exceeded. Upgrade to
            resolve.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.ScriptFailed">
            <summary>
            Error code indicating that a Cloud Code script failed.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.ValidationFailed">
            <summary>
            Error code indicating that a Cloud Code validation failed.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.FileDeleteFailed">
            <summary>
            Error code indicating that deleting a file failed.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.RequestLimitExceeded">
            <summary>
            Error code indicating that the application has exceeded its request limit.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidEventName">
            <summary>
            Error code indicating that the provided event name is invalid.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.UsernameMissing">
            <summary>
            Error code indicating that the username is missing or empty.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.PasswordMissing">
            <summary>
            Error code indicating that the password is missing or empty.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.UsernameTaken">
            <summary>
            Error code indicating that the username has already been taken.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.EmailTaken">
            <summary>
            Error code indicating that the email has already been taken.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.EmailMissing">
            <summary>
            Error code indicating that the email is missing, but must be specified.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.EmailNotFound">
            <summary>
            Error code indicating that a user with the specified email was not found.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.SessionMissing">
            <summary>
            Error code indicating that a user object without a valid session could
            not be altered.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.MustCreateUserThroughSignup">
            <summary>
            Error code indicating that a user can only be created through signup.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.AccountAlreadyLinked">
            <summary>
            Error code indicating that an an account being linked is already linked
            to another user.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidSessionToken">
            <summary>
            Error code indicating that the current session token is invalid.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.LinkedIdMissing">
            <summary>
            Error code indicating that a user cannot be linked to an account because
            that account's id could not be found.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidLinkedSession">
            <summary>
            Error code indicating that a user with a linked (e.g. Facebook) account
            has an invalid session.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.UnsupportedService">
            <summary>
            Error code indicating that a service being linked (e.g. Facebook or
            Twitter) is unsupported.
            </summary>
        </member>
        <member name="T:Parse.ParseExtensions">
            <summary>
            Provides convenience extension methods for working with collections
            of ParseObjects so that you can easily save and fetch them in batches.
            </summary>
        </member>
        <member name="M:Parse.ParseExtensions.SaveAllAsync``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Saves all of the ParseObjects in the enumeration. Equivalent to
            calling <see cref="M:Parse.ParseObject.SaveAllAsync``1(System.Collections.Generic.IEnumerable{``0})"/>.
            </summary>
            <param name="objects">The objects to save.</param>
        </member>
        <member name="M:Parse.ParseExtensions.SaveAllAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Saves all of the ParseObjects in the enumeration. Equivalent to
            calling
            <see cref="M:Parse.ParseObject.SaveAllAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="objects">The objects to save.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseExtensions.FetchAllAsync``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Fetches all of the objects in the enumeration. Equivalent to
            calling <see cref="M:Parse.ParseObject.FetchAllAsync``1(System.Collections.Generic.IEnumerable{``0})"/>.
            </summary>
            <param name="objects">The objects to save.</param>
        </member>
        <member name="M:Parse.ParseExtensions.FetchAllAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Fetches all of the objects in the enumeration. Equivalent to
            calling
            <see cref="M:Parse.ParseObject.FetchAllAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="objects">The objects to fetch.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseExtensions.FetchAllIfNeededAsync``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Fetches all of the objects in the enumeration that don't already have
            data. Equivalent to calling
            <see cref="M:Parse.ParseObject.FetchAllIfNeededAsync``1(System.Collections.Generic.IEnumerable{``0})"/>.
            </summary>
            <param name="objects">The objects to fetch.</param>
        </member>
        <member name="M:Parse.ParseExtensions.FetchAllIfNeededAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Fetches all of the objects in the enumeration that don't already have
            data. Equivalent to calling
            <see cref="M:Parse.ParseObject.FetchAllIfNeededAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="objects">The objects to fetch.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseExtensions.Or``1(Parse.ParseQuery{``0},Parse.ParseQuery{``0}[])">
            <summary>
            Constructs a query that is the or of the given queries.
            </summary>
            <typeparam name="T">The type of ParseObject being queried.</typeparam>
            <param name="source">An initial query to 'or' with additional queries.</param>
            <param name="queries">The list of ParseQueries to 'or' together.</param>
            <returns>A query that is the or of the given queries.</returns>
        </member>
        <member name="M:Parse.ParseExtensions.FetchAsync``1(``0)">
            <summary>
            Fetches this object with the data from the server.
            </summary>
        </member>
        <member name="M:Parse.ParseExtensions.FetchAsync``1(``0,System.Threading.CancellationToken)">
            <summary>
            Fetches this object with the data from the server.
            </summary>
            <param name="obj">The ParseObject to fetch.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseExtensions.FetchIfNeededAsync``1(``0)">
            <summary>
            If this ParseObject has not been fetched (i.e. <see cref="P:Parse.ParseObject.IsDataAvailable"/> returns
            false), fetches this object with the data from the server.
            </summary>
            <param name="obj">The ParseObject to fetch.</param>
        </member>
        <member name="M:Parse.ParseExtensions.FetchIfNeededAsync``1(``0,System.Threading.CancellationToken)">
            <summary>
            If this ParseObject has not been fetched (i.e. <see cref="P:Parse.ParseObject.IsDataAvailable"/> returns
            false), fetches this object with the data from the server.
            </summary>
            <param name="obj">The ParseObject to fetch.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="T:Parse.ParseFieldNameAttribute">
            <summary>
            Specifies a field name for a property on a ParseObject subclass.
            </summary>
        </member>
        <member name="M:Parse.ParseFieldNameAttribute.#ctor(System.String)">
            <summary>
            Constructs a new ParseFieldName attribute.
            </summary>
            <param name="fieldName">The name of the field on the ParseObject that the
            property represents.</param>
        </member>
        <member name="P:Parse.ParseFieldNameAttribute.FieldName">
            <summary>
            Gets the name of the field represented by this property.
            </summary>
        </member>
        <member name="T:Parse.ParseFile">
            <summary>
            ParseFile is a local representation of a file that is saved to the Parse cloud.
            </summary>
            <example>
            The workflow is to construct a <see cref="T:Parse.ParseFile"/> with data and a filename,
            then save it and set it as a field on a ParseObject:
            
            <code>
            var file = new ParseFile("hello.txt",
                new MemoryStream(Encoding.UTF8.GetBytes("hello")));
            await file.SaveAsync();
            var obj = new ParseObject("TestObject");
            obj["file"] = file;
            await obj.SaveAsync();
            </code>
            </example>
        </member>
        <member name="M:Parse.ParseFile.#ctor(System.String,System.Byte[],System.String)">
            <summary>
            Creates a new file from a byte array and a name.
            </summary>
            <param name="name">The file's name, ideally with an extension. The file name
            must begin with an alphanumeric character, and consist of alphanumeric
            characters, periods, spaces, underscores, or dashes.</param>
            <param name="data">The file's data.</param>
            <param name="mimeType">To specify the content-type used when uploading the
            file, provide this parameter.</param>
        </member>
        <member name="M:Parse.ParseFile.#ctor(System.String,System.IO.Stream,System.String)">
            <summary>
            Creates a new file from a stream and a name.
            </summary>
            <param name="name">The file's name, ideally with an extension. The file name
            must begin with an alphanumeric character, and consist of alphanumeric
            characters, periods, spaces, underscores, or dashes.</param>
            <param name="data">The file's data.</param>
            <param name="mimeType">To specify the content-type used when uploading the
            file, provide this parameter.</param>
        </member>
        <member name="M:Parse.ParseFile.SaveAsync">
            <summary>
            Saves the file to the Parse cloud.
            </summary>
        </member>
        <member name="M:Parse.ParseFile.SaveAsync(System.Threading.CancellationToken)">
            <summary>
            Saves the file to the Parse cloud.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseFile.SaveAsync(System.IProgress{Parse.ParseUploadProgressEventArgs})">
            <summary>
            Saves the file to the Parse cloud.
            </summary>
            <param name="progress">The progress callback.</param>
        </member>
        <member name="M:Parse.ParseFile.SaveAsync(System.IProgress{Parse.ParseUploadProgressEventArgs},System.Threading.CancellationToken)">
            <summary>
            Saves the file to the Parse cloud.
            </summary>
            <param name="progress">The progress callback.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="P:Parse.ParseFile.IsDirty">
            <summary>
            Gets whether the file still needs to be saved.
            </summary>
        </member>
        <member name="P:Parse.ParseFile.Name">
            <summary>
            Gets the name of the file. Before save is called, this is the filename given by
            the user. After save is called, that name gets prefixed with a unique identifier.
            </summary>
        </member>
        <member name="P:Parse.ParseFile.MimeType">
            <summary>
            Gets the MIME type of the file. This is either passed in to the constructor or
            inferred from the file extension. "unknown/unknown" will be used if neither is 
            available.
            </summary>
        </member>
        <member name="P:Parse.ParseFile.Url">
            <summary>
            Gets the url of the file. It is only available after you save the file or after
            you get the file from a <see cref="T:Parse.ParseObject"/>.
            </summary>
        </member>
        <member name="T:Parse.ParseGeoDistance">
            <summary>
            Represents a distance between two ParseGeoPoints.
            </summary>
        </member>
        <member name="M:Parse.ParseGeoDistance.#ctor(System.Double)">
            <summary>
            Creates a ParseGeoDistance.
            </summary>
            <param name="radians">The distance in radians.</param>
        </member>
        <member name="M:Parse.ParseGeoDistance.FromMiles(System.Double)">
            <summary>
            Gets a ParseGeoDistance from a number of miles.
            </summary>
            <param name="miles">The number of miles.</param>
            <returns>A ParseGeoDistance for the given number of miles.</returns>
        </member>
        <member name="M:Parse.ParseGeoDistance.FromKilometers(System.Double)">
            <summary>
            Gets a ParseGeoDistance from a number of kilometers.
            </summary>
            <param name="kilometers">The number of kilometers.</param>
            <returns>A ParseGeoDistance for the given number of kilometers.</returns>
        </member>
        <member name="M:Parse.ParseGeoDistance.FromRadians(System.Double)">
            <summary>
            Gets a ParseGeoDistance from a number of radians.
            </summary>
            <param name="radians">The number of radians.</param>
            <returns>A ParseGeoDistance for the given number of radians.</returns>
        </member>
        <member name="P:Parse.ParseGeoDistance.Radians">
            <summary>
            Gets the distance in radians.
            </summary>
        </member>
        <member name="P:Parse.ParseGeoDistance.Miles">
            <summary>
            Gets the distance in miles.
            </summary>
        </member>
        <member name="P:Parse.ParseGeoDistance.Kilometers">
            <summary>
            Gets the distance in kilometers.
            </summary>
        </member>
        <member name="T:Parse.ParseGeoPoint">
            <summary>
            ParseGeoPoint represents a latitude / longitude point that may be associated
            with a key in a ParseObject or used as a reference point for geo queries.
            This allows proximity-based queries on the key.
            
            Only one key in a class may contain a GeoPoint.
            </summary>
        </member>
        <member name="M:Parse.ParseGeoPoint.#ctor(System.Double,System.Double)">
            <summary>
            Constructs a ParseGeoPoint with the specified latitude and longitude.
            </summary>
            <param name="latitude">The point's latitude.</param>
            <param name="longitude">The point's longitude.</param>
        </member>
        <member name="M:Parse.ParseGeoPoint.DistanceTo(Parse.ParseGeoPoint)">
            <summary>
            Get the distance in radians between this point and another GeoPoint. This is the smallest angular
            distance between the two points.
            </summary>
            <param name="point">GeoPoint describing the other point being measured against.</param>
            <returns>The distance in between the two points.</returns>
        </member>
        <member name="P:Parse.ParseGeoPoint.Latitude">
            <summary>
            Gets or sets the latitude of the GeoPoint. Valid range is [-90, 90].
            Extremes should not be used.
            </summary>
        </member>
        <member name="P:Parse.ParseGeoPoint.Longitude">
            <summary>
            Gets or sets the longitude. Valid range is [-180, 180].
            Extremes should not be used.
            </summary>
        </member>
        <member name="T:Parse.ParseInstallation">
            <summary>
             Represents this app installed on this device. Use this class to track information you want
             to sample from (i.e. if you update a field on app launch, you can issue a query to see
             the number of devices which were active in the last N hours).
            </summary>
        </member>
        <member name="T:Parse.ParseObject">
            <summary>
            The ParseObject is a local representation of data that can be saved and
            retrieved from the Parse cloud.</summary>
            <remarks>
            <para>
            The basic workflow for creating new data is to construct a new ParseObject,
            use the indexer to fill it with data, and then use SaveAsync() to persist to the
            database.
            </para>
            <para>
            The basic workflow for accessing existing data is to use a ParseQuery
            to specify which existing data to retrieve.
            </para>
            </remarks>
        </member>
        <member name="M:Parse.ParseObject.#ctor">
            <summary>
            Constructor for use in ParseObject subclasses. Subclasses must specify a ParseClassName attribute.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.#ctor(System.String)">
            <summary>
            Constructs a new ParseObject with no data in it. A ParseObject constructed in this way will
            not have an ObjectId and will not persist to the database until <see cref="M:Parse.ParseObject.SaveAsync"/>
            is called.
            </summary>
            <remarks>
            Class names must be alphanumerical plus underscore, and start with a letter. It is recommended
            to name classes in CamelCaseLikeThis.
            </remarks>
            <param name="className">The className for this ParseObject.</param>
        </member>
        <member name="M:Parse.ParseObject.Create(System.String)">
            <summary>
            Creates a new ParseObject based upon a class name. If the class name is a special type (e.g.
            for <see cref="T:Parse.ParseUser"/>), then the appropriate type of ParseObject is returned.
            </summary>
            <param name="className">The class of object to create.</param>
            <returns>A new ParseObject for the given class name.</returns>
        </member>
        <member name="M:Parse.ParseObject.CreateWithoutData(System.String,System.String)">
            <summary>
            Creates a reference to an existing ParseObject for use in creating associations between
            ParseObjects. Calling <see cref="P:Parse.ParseObject.IsDataAvailable"/> on this object will return
            <c>false</c> until <see cref="M:Parse.ParseExtensions.FetchIfNeededAsync``1(``0)"/> has been called.
            No network request will be made.
            </summary>
            <param name="className">The object's class.</param>
            <param name="objectId">The object id for the referenced object.</param>
            <returns>A ParseObject without data.</returns>
        </member>
        <member name="M:Parse.ParseObject.Create``1">
            <summary>
            Creates a new ParseObject based upon a given subclass type.
            </summary>
            <returns>A new ParseObject for the given class name.</returns>
        </member>
        <member name="M:Parse.ParseObject.CreateWithoutData``1(System.String)">
            <summary>
            Creates a reference to an existing ParseObject for use in creating associations between
            ParseObjects. Calling <see cref="P:Parse.ParseObject.IsDataAvailable"/> on this object will return
            <c>false</c> until <see cref="M:Parse.ParseExtensions.FetchIfNeededAsync``1(``0)"/> has been called.
            No network request will be made.
            </summary>
            <param name="objectId">The object id for the referenced object.</param>
            <returns>A ParseObject without data.</returns>
        </member>
        <member name="M:Parse.ParseObject.SetProperty``1(``0,System.String)">
            <summary>
            Sets the value of a property based upon its associated ParseFieldName attribute.
            </summary>
            <param name="value">The new value.</param>
            <param name="propertyName">The name of the property.</param>
            <typeparam name="T">The type for the property.</typeparam>
        </member>
        <member name="M:Parse.ParseObject.GetRelationProperty``1(System.String)">
            <summary>
            Gets a relation for a property based upon its associated ParseFieldName attribute.
            </summary>
            <returns>The ParseRelation for the property.</returns>
            <param name="propertyName">The name of the property.</param>
            <typeparam name="T">The ParseObject subclass type of the ParseRelation.</typeparam>
        </member>
        <member name="M:Parse.ParseObject.GetProperty``1(System.String)">
            <summary>
            Gets the value of a property based upon its associated ParseFieldName attribute.
            </summary>
            <returns>The value of the property.</returns>
            <param name="propertyName">The name of the property.</param>
            <typeparam name="T">The return type of the property.</typeparam>
        </member>
        <member name="M:Parse.ParseObject.GetProperty``1(``0,System.String)">
            <summary>
            Gets the value of a property based upon its associated ParseFieldName attribute.
            </summary>
            <returns>The value of the property.</returns>
            <param name="defaultValue">The value to return if the property is not present on the ParseObject.</param>
            <param name="propertyName">The name of the property.</param>
            <typeparam name="T">The return type of the property.</typeparam>
        </member>
        <member name="M:Parse.ParseObject.SetDefaultValues">
            <summary>
            Allows subclasses to set values for non-pointer construction.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.RegisterSubclass``1">
            <summary>
            Registers a custom subclass type with the Parse SDK, enabling strong-typing of those ParseObjects whenever
            they appear. Subclasses must specify the ParseClassName attribute, have a default constructor, and properties
            backed by ParseObject fields should have ParseFieldName attributes supplied.
            </summary>
            <typeparam name="T">The ParseObject subclass type to register.</typeparam>
        </member>
        <member name="M:Parse.ParseObject.Revert">
            <summary>
            Clears any changes to this object made since the last call to <see cref="M:Parse.ParseObject.SaveAsync"/>.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.DeepTraversal(System.Object,System.Boolean,System.Boolean)">
            <summary>
            Flattens dictionaries and lists into a single enumerable of all contained objects
            that can then be queried over.
            </summary>
            <param name="root">The root of the traversal</param>
            <param name="traverseParseObjects">Whether to traverse into ParseObjects' children</param>
            <param name="yieldRoot">Whether to include the root in the result</param>
            <returns></returns>
        </member>
        <member name="M:Parse.ParseObject.CollectFetchedObjects">
            <summary>
            Deep traversal of this object to grab a copy of any object referenced by this object.
            These instances may have already been fetched, and we don't want to lose their data when
            refreshing or saving.
            </summary>
            <returns>Map of objectId to ParseObject which have been fetched.</returns>
        </member>
        <member name="M:Parse.ParseObject.StartSave">
            <summary>
            Pushes new operations onto the queue and returns the current set of operations.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.SaveAsync">
            <summary>
            Saves this object to the server.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.SaveAsync(System.Threading.CancellationToken)">
            <summary>
            Saves this object to the server.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseObject.SaveAllAsync``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Saves each object in the provided list.
            </summary>
            <param name="objects">The objects to save.</param>
        </member>
        <member name="M:Parse.ParseObject.SaveAllAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Saves each object in the provided list.
            </summary>
            <param name="objects">The objects to save.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseObject.FetchAsyncInternal(System.Threading.CancellationToken)">
            <summary>
            Fetches this object with the data from the server.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseObject.FetchIfNeededAsyncInternal(System.Threading.CancellationToken)">
            <summary>
            If this ParseObject has not been fetched (i.e. <see cref="P:Parse.ParseObject.IsDataAvailable"/> returns
            false), fetches this object with the data from the server.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseObject.FetchAllIfNeededAsync``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Fetches all of the objects that don't have data in the provided list.
            </summary>
            <returns>The list passed in for convenience.</returns>
        </member>
        <member name="M:Parse.ParseObject.FetchAllIfNeededAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Fetches all of the objects that don't have data in the provided list.
            </summary>
            <param name="objects">The objects to fetch.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The list passed in for convenience.</returns>
        </member>
        <member name="M:Parse.ParseObject.FetchAllAsync``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Fetches all of the objects in the provided list.
            </summary>
            <param name="objects">The objects to fetch.</param>
            <returns>The list passed in for convenience.</returns>
        </member>
        <member name="M:Parse.ParseObject.FetchAllAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Fetches all of the objects in the provided list.
            </summary>
            <param name="objects">The objects to fetch.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The list passed in for convenience.</returns>
        </member>
        <member name="M:Parse.ParseObject.FetchAllInternalAsync``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Threading.Tasks.Task,System.Threading.CancellationToken)">
            <summary>
            Fetches all of the objects in the list.
            </summary>
            <param name="objects">The objects to fetch.</param>
            <param name="force">If false, only objects without data will be fetched.</param>
            <param name="toAwait">A task to await before starting.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The list passed in for convenience.</returns>
        </member>
        <member name="M:Parse.ParseObject.DeleteAsync">
            <summary>
            Deletes this object on the server.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.DeleteAsync(System.Threading.CancellationToken)">
            <summary>
            Deletes this object on the server.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseObject.DeleteAllAsync``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Deletes each object in the provided list.
            </summary>
            <param name="objects">The objects to delete.</param>
        </member>
        <member name="M:Parse.ParseObject.DeleteAllAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Deletes each object in the provided list.
            </summary>
            <param name="objects">The objects to delete.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseObject.CollectDirtyChildren(System.Object,System.Collections.Generic.IList{Parse.ParseObject})">
            <summary>
            Helper version of CollectDirtyChildren so that callers don't have to add the internally
            used parameters.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.CanBeSerializedAsValue(System.Object)">
            <summary>
            Returns true if the given object can be serialized for saving as a value
            that is pointed to by a ParseObject.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.EnqueueForAll``1(System.Collections.Generic.IEnumerable{Parse.ParseObject},System.Func{System.Threading.Tasks.Task,System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>
            Adds a task to the queue for all of the given objects.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.Remove(System.String)">
            <summary>
            Removes a key from the object's data if it exists.
            </summary>
            <param name="key">The key to remove.</param>
        </member>
        <member name="M:Parse.ParseObject.RebuildEstimatedData">
            <summary>
            Regenerates the estimatedData map from the serverData and operations.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.PerformOperation(System.String,Parse.Internal.IParseFieldOperation)">
            <summary>
            PerformOperation is like setting a value at an index, but instead of
            just taking a new value, it takes a ParseFieldOperation that modifies the value.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.OnSettingValue(System.String@,System.Object@)">
            <summary>
            Override to run validations on key/value pairs. Make sure to still
            call the base version.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.Set(System.String,System.Object)">
            <summary>
            Perform Set internally which is not gated by mutability check.
            </summary>
            <param name="key">key for the object.</param>
            <param name="value">the value for the key.</param>
        </member>
        <member name="M:Parse.ParseObject.Increment(System.String)">
            <summary>
            Atomically increments the given key by 1.
            </summary>
            <param name="key">The key to increment.</param>
        </member>
        <member name="M:Parse.ParseObject.Increment(System.String,System.Int64)">
            <summary>
            Atomically increments the given key by the given number.
            </summary>
            <param name="key">The key to increment.</param>
            <param name="amount">The amount to increment by.</param>
        </member>
        <member name="M:Parse.ParseObject.Increment(System.String,System.Double)">
            <summary>
            Atomically increments the given key by the given number.
            </summary>
            <param name="key">The key to increment.</param>
            <param name="amount">The amount to increment by.</param>
        </member>
        <member name="M:Parse.ParseObject.AddToList(System.String,System.Object)">
            <summary>
            Atomically adds an object to the end of the list associated with the given key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The object to add.</param>
        </member>
        <member name="M:Parse.ParseObject.AddRangeToList``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Atomically adds objects to the end of the list associated with the given key.
            </summary>
            <param name="key">The key.</param>
            <param name="values">The objects to add.</param>
        </member>
        <member name="M:Parse.ParseObject.AddUniqueToList(System.String,System.Object)">
            <summary>
            Atomically adds an object to the end of the list associated with the given key,
            only if it is not already present in the list. The position of the insert is not
            guaranteed.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The object to add.</param>
        </member>
        <member name="M:Parse.ParseObject.AddRangeUniqueToList``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Atomically adds objects to the end of the list associated with the given key,
            only if they are not already present in the list. The position of the inserts are not
            guaranteed.
            </summary>
            <param name="key">The key.</param>
            <param name="values">The objects to add.</param>
        </member>
        <member name="M:Parse.ParseObject.RemoveAllFromList``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Atomically removes all instances of the objects in <paramref name="values"/>
            from the list associated with the given key.
            </summary>
            <param name="key">The key.</param>
            <param name="values">The objects to remove.</param>
        </member>
        <member name="M:Parse.ParseObject.ContainsKey(System.String)">
            <summary>
            Returns whether this object has a particular key.
            </summary>
            <param name="key">The key to check for</param>
        </member>
        <member name="M:Parse.ParseObject.Get``1(System.String)">
            <summary>
            Gets a value for the key of a particular type.
            <typeparam name="T">The type to convert the value to. Supported types are
            ParseObject and its descendents, Parse types such as ParseRelation and ParseGeopoint,
            primitive types,IList&lt;T&gt;, IDictionary&lt;string, T&gt;, and strings.</typeparam>
            <param name="key">The key of the element to get.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is
            retrieved and <paramref name="key"/> is not found.</exception>
            </summary>
        </member>
        <member name="M:Parse.ParseObject.GetRelation``1(System.String)">
            <summary>
            Access or create a Relation value for a key.
            </summary>
            <typeparam name="T">The type of object to create a relation for.</typeparam>
            <param name="key">The key for the relation field.</param>
            <returns>A ParseRelation for the key.</returns>
        </member>
        <member name="M:Parse.ParseObject.TryGetValue``1(System.String,``0@)">
            <summary>
            Populates result with the value for the key, if possible.
            </summary>
            <typeparam name="T">The desired type for the value.</typeparam>
            <param name="key">The key to retrieve a value for.</param>
            <param name="result">The value for the given key, converted to the
            requested type, or null if unsuccessful.</param>
            <returns>true if the lookup and conversion succeeded, otherwise
            false.</returns>
        </member>
        <member name="M:Parse.ParseObject.HasSameId(Parse.ParseObject)">
            <summary>
            A helper function for checking whether two ParseObjects point to
            the same object in the cloud.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.IsKeyDirty(System.String)">
            <summary>
            Indicates whether key is unsaved for this ParseObject.
            </summary>
            <param name="key">The key to check for.</param>
            <returns><c>true</c> if the key has been altered and not saved yet, otherwise
            <c>false</c>.</returns>
        </member>
        <member name="M:Parse.ParseObject.SetObjectIdInternal(System.String)">
            <summary>
            Sets the objectId without marking dirty.
            </summary>
            <param name="objectId">The new objectId</param>
        </member>
        <member name="M:Parse.ParseObject.Add(System.String,System.Object)">
            <summary>
            Adds a value for the given key, throwing an Exception if the key
            already has a value.
            </summary>
            <remarks>
            This allows you to use collection initialization syntax when creating ParseObjects,
            such as:
            <code>
            var obj = new ParseObject("MyType")
            {
                {"name", "foo"},
                {"count", 10},
                {"found", false}
            };
            </code>
            </remarks>
            <param name="key">The key for which a value should be set.</param>
            <param name="value">The value for the key.</param>
        </member>
        <member name="M:Parse.ParseObject.GetQuery(System.String)">
            <summary>
            Gets a <see cref="T:Parse.ParseQuery`1"/> for the type of object specified by
            <paramref name="className"/>
            </summary>
            <param name="className">The class name of the object.</param>
            <returns>A new <see cref="T:Parse.ParseQuery`1"/>.</returns>
        </member>
        <member name="M:Parse.ParseObject.OnFieldsChanged(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Raises change notifications for all properties associated with the given
            field names. If fieldNames is null, this will notify for all known field-linked
            properties (e.g. this happens when we recalculate all estimated data from scratch)
            </summary>
        </member>
        <member name="M:Parse.ParseObject.OnPropertyChanged(System.String)">
            <summary>
            Raises change notifications for a property. Passing null or the empty string
            notifies the binding framework that all properties/indexes have changed.
            Passing "Item[]" tells the binding framework that all indexed values
            have changed (but not all properties)
            </summary>
        </member>
        <member name="P:Parse.ParseObject.Item(System.String)">
            <summary>
            Gets or sets a value on the object. It is recommended to name
            keys in partialCamelCaseLikeThis.
            </summary>
            <param name="key">The key for the object. Keys must be alphanumeric plus underscore
            and start with a letter.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is
            retrieved and <paramref name="key"/> is not found.</exception>
            <returns>The value for the key.</returns>
        </member>
        <member name="P:Parse.ParseObject.IsDataAvailable">
            <summary>
            Gets whether the ParseObject has been fetched.
            </summary>
        </member>
        <member name="P:Parse.ParseObject.Keys">
            <summary>
            Gets a set view of the keys contained in this object. This does not include createdAt,
            updatedAt, or objectId. It does include things like username and ACL.
            </summary>
        </member>
        <member name="P:Parse.ParseObject.ACL">
            <summary>
            Gets or sets the ParseACL governing this object.
            </summary>
        </member>
        <member name="P:Parse.ParseObject.IsNew">
            <summary>
            Returns true if this object was created by the Parse server when the
            object might have already been there (e.g. in the case of a Facebook
            login)
            </summary>
        </member>
        <member name="P:Parse.ParseObject.UpdatedAt">
            <summary>
            Gets the last time this object was updated as the server sees it, so that if you make changes
            to a ParseObject, then wait a while, and then call <see cref="M:Parse.ParseObject.SaveAsync"/>, the updated time
            will be the time of the <see cref="M:Parse.ParseObject.SaveAsync"/> call rather than the time the object was
            changed locally.
            </summary>
        </member>
        <member name="P:Parse.ParseObject.CreatedAt">
            <summary>
            Gets the first time this object was saved as the server sees it, so that if you create a
            ParseObject, then wait a while, and then call <see cref="M:Parse.ParseObject.SaveAsync"/>, the
            creation time will be the time of the first <see cref="M:Parse.ParseObject.SaveAsync"/> call rather than
            the time the object was created locally.
            </summary>
        </member>
        <member name="P:Parse.ParseObject.IsDirty">
            <summary>
            Indicates whether this ParseObject has unsaved changes.
            </summary>
        </member>
        <member name="P:Parse.ParseObject.ObjectId">
            <summary>
            Gets or sets the object id. An object id is assigned as soon as an object is
            saved to the server. The combination of a <see cref="P:Parse.ParseObject.ClassName"/> and an
            <see cref="P:Parse.ParseObject.ObjectId"/> uniquely identifies an object in your application.
            </summary>
        </member>
        <member name="P:Parse.ParseObject.ClassName">
            <summary>
            Gets the class name for the ParseObject.
            </summary>
        </member>
        <member name="E:Parse.ParseObject.PropertyChanged">
            <summary>
            Occurs when a property value changes.
            </summary>
        </member>
        <member name="M:Parse.ParseInstallation.#ctor">
            <summary>
            Constructs a new ParseInstallation. Generally, you should not need to construct
            ParseInstallations yourself. Instead use <see cref="P:Parse.ParseInstallation.CurrentInstallation"/>.
            </summary>
        </member>
        <member name="M:Parse.ParseInstallation.GetLocaleIdentifier">
            <summary>
            Gets the locale identifier in the format: [language code]-[COUNTRY CODE].
            </summary>
            <returns>The locale identifier in the format: [language code]-[COUNTRY CODE].</returns>
        </member>
        <member name="F:Parse.ParseInstallation.TimeZoneNameMap">
            <summary>
            This mapping of Windows names to a standard everyone else uses is maintained 
            by the Unicode consortium, which makes this officially the first helpful
            interaction between Unicode and Microsoft.
            Unfortunately this is a little lossy in that we only store the first mapping in each zone because
            Microsoft does not give us more granular location information.
            Built from http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/zone_tzid.html
            </summary>
        </member>
        <member name="F:Parse.ParseInstallation.TimeZoneOffsetMap">
            <summary>
            This is a mapping of odd TimeZone offsets to their respective IANA codes across the world.
            This list was compiled from painstakingly pouring over the information available at
            https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
            </summary>
        </member>
        <member name="M:Parse.ParseInstallation.SetDeviceTokenFromData(System.Byte[])">
            <summary>
            Sets <see cref="P:Parse.ParseInstallation.DeviceToken"/> with byte array provided by APNS.
            </summary>
            <remarks>
            This method is only useful for iOS/MacOSX platform.
            </remarks>
            <param name="deviceToken"></param>
        </member>
        <member name="P:Parse.ParseInstallation.CurrentInstallation">
            <summary>
            Gets the ParseInstallation representing this app on this device.
            </summary>
        </member>
        <member name="P:Parse.ParseInstallation.Query">
            <summary>
            Constructs a <see cref="T:Parse.ParseQuery`1"/> for ParseInstallations.
            </summary>
            <remarks>
            Only the following types of queries are allowed for installations:
            
            <code>
            query.GetAsync(objectId)
            query.WhereEqualTo(key, value)
            query.WhereMatchesKeyInQuery&lt;TOther&gt;(key, keyInQuery, otherQuery)
            </code>
            
            You can add additional query conditions, but one of the above must appear as a top-level <c>AND</c>
            clause in the query.
            </remarks>
        </member>
        <member name="P:Parse.ParseInstallation.InstallationId">
            <summary>
            A GUID that uniquely names this app installed on this device.
            </summary>
        </member>
        <member name="P:Parse.ParseInstallation.DeviceType">
            <summary>
            The runtime target of this installation object.
            </summary>
        </member>
        <member name="P:Parse.ParseInstallation.AppName">
            <summary>
            The user-friendly display name of this application.
            </summary>
        </member>
        <member name="P:Parse.ParseInstallation.AppVersion">
            <summary>
            A version string consisting of Major.Minor.Build.Revision.
            </summary>
        </member>
        <member name="P:Parse.ParseInstallation.AppIdentifier">
            <summary>
            The system-dependent unique identifier of this installation. This identifier should be
            sufficient to distinctly name an app on stores which may allow multiple apps with the
            same display name.
            </summary>
        </member>
        <member name="P:Parse.ParseInstallation.TimeZone">
            <summary>
            The time zone in which this device resides. This string is in the tz database format
            Parse uses for local-time pushes. Due to platform restrictions, the mapping is less
            granular on Windows than it may be on other systems. E.g. The zones
            America/Vancouver America/Dawson America/Whitehorse, America/Tijuana, PST8PDT, and
            America/Los_Angeles are all reported as America/Los_Angeles.
            </summary>
        </member>
        <member name="P:Parse.ParseInstallation.LocaleIdentifier">
            <summary>
            The users locale. This field gets automatically populated by the SDK.
            Can be null (Parse Push uses default language in this case).
            </summary>
        </member>
        <member name="P:Parse.ParseInstallation.ParseVersion">
            <summary>
            The version of the Parse SDK used to build this application.
            </summary>
        </member>
        <member name="P:Parse.ParseInstallation.Channels">
            <summary>
            A sequence of arbitrary strings which are used to identify this installation for push notifications.
            By convention, the empty string is known as the "Broadcast" channel.
            </summary>
        </member>
        <member name="P:Parse.ParseInstallation.DeviceToken">
            <summary>
            The device token of the installation. Typically generated by APNS or GCM.
            </summary>
        </member>
        <member name="P:Parse.ParseInstallation.Badge">
            <summary>
            iOS Badge.
            </summary>
        </member>
        <member name="T:Parse.ParsePushNotificationEventArgs">
            <summary>
            A wrapper around Parse push notification payload.
            </summary>
        </member>
        <member name="P:Parse.ParsePushNotificationEventArgs.Payload">
            <summary>
            The payload of the push notification as <c>IDictionary</c>.
            </summary>
        </member>
        <member name="P:Parse.ParsePushNotificationEventArgs.StringPayload">
            <summary>
            The payload of the push notification as <c>string</c>.
            </summary>
        </member>
        <member name="T:Parse.ParseQuery`1">
             <summary>
             The ParseQuery class defines a query that is used to fetch ParseObjects. The
             most common use case is finding all objects that match a query through the
             <see cref="M:Parse.ParseQuery`1.FindAsync"/> method.
             </summary>
             <example>
             This sample code fetches all objects of
             class <c>"MyClass"</c>:
            
             <code>
             ParseQuery query = new ParseQuery("MyClass");
             IEnumerable&lt;ParseObject&gt; result = await query.FindAsync();
             </code>
            
             A ParseQuery can also be used to retrieve a single object whose id is known,
             through the <see cref="M:Parse.ParseQuery`1.GetAsync(System.String)"/> method. For example, this sample code
             fetches an object of class <c>"MyClass"</c> and id <c>myId</c>.
            
             <code>
             ParseQuery query = new ParseQuery("MyClass");
             ParseObject result = await query.GetAsync(myId);
             </code>
            
             A ParseQuery can also be used to count the number of objects that match the
             query without retrieving all of those objects. For example, this sample code
             counts the number of objects of the class <c>"MyClass"</c>.
            
             <code>
             ParseQuery query = new ParseQuery("MyClass");
             int count = await query.CountAsync();
             </code>
             </example>
        </member>
        <member name="M:Parse.ParseQuery`1.#ctor(Parse.ParseQuery{`0},System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Private constructor for composition of queries. A source query is required,
            but the remaining values can be null if they won't be changed in this
            composition.
            </summary>
        </member>
        <member name="M:Parse.ParseQuery`1.#ctor">
            <summary>
            Constructs a query based upon the ParseObject subclass used as the generic parameter for the ParseQuery.
            </summary>
        </member>
        <member name="M:Parse.ParseQuery`1.#ctor(System.String)">
            <summary>
            Constructs a query. A default query with no further parameters will retrieve
            all <see cref="T:Parse.ParseObject"/>s of the provided class.
            </summary>
            <param name="className">The name of the class to retrieve ParseObjects for.</param>
        </member>
        <member name="M:Parse.ParseQuery`1.Or(System.Collections.Generic.IEnumerable{Parse.ParseQuery{`0}})">
            <summary>
            Constructs a query that is the or of the given queries.
            </summary>
            <param name="queries">The list of ParseQueries to 'or' together.</param>
            <returns>A ParseQquery that is the 'or' of the passed in queries.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.OrderBy(System.String)">
            <summary>
            Sorts the results in ascending order by the given key.
            This will override any existing ordering for the query.
            </summary>
            <param name="key">The key to order by.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.OrderByDescending(System.String)">
            <summary>
            Sorts the results in descending order by the given key.
            This will override any existing ordering for the query.
            </summary>
            <param name="key">The key to order by.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.ThenBy(System.String)">
             <summary>
             Sorts the results in ascending order by the given key, after previous
             ordering has been applied.
            
             This method can only be called if there is already an <see cref="M:Parse.ParseQuery`1.OrderBy(System.String)"/>
             or <see cref="M:Parse.ParseQuery`1.OrderByDescending(System.String)"/>
             on this query.
             </summary>
             <param name="key">The key to order by.</param>
             <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.ThenByDescending(System.String)">
             <summary>
             Sorts the results in descending order by the given key, after previous
             ordering has been applied.
            
             This method can only be called if there is already an <see cref="M:Parse.ParseQuery`1.OrderBy(System.String)"/>
             or <see cref="M:Parse.ParseQuery`1.OrderByDescending(System.String)"/> on this query.
             </summary>
             <param name="key">The key to order by.</param>
             <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.Include(System.String)">
            <summary>
            Include nested ParseObjects for the provided key. You can use dot notation
            to specify which fields in the included objects should also be fetched.
            </summary>
            <param name="key">The key that should be included.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.Select(System.String)">
            <summary>
            Restrict the fields of returned ParseObjects to only include the provided key.
            If this is called multiple times, then all of the keys specified in each of
            the calls will be included.
            </summary>
            <param name="key">The key that should be included.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.Skip(System.Int32)">
            <summary>
            Skips a number of results before returning. This is useful for pagination
            of large queries. Chaining multiple skips together will cause more results
            to be skipped.
            </summary>
            <param name="count">The number of results to skip.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.Limit(System.Int32)">
            <summary>
            Controls the maximum number of results that are returned. Setting a negative
            limit denotes retrieval without a limit. Chaining multiple limits
            results in the last limit specified being used. The default limit is
            100, with a maximum of 1000 results being returned at a time.
            </summary>
            <param name="count">The maximum number of results to return.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereContainedIn``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds a constraint to the query that requires a particular key's value to be
            contained in the provided list of values.
            </summary>
            <param name="key">The key to check.</param>
            <param name="values">The values that will match.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereContainsAll``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add a constraint to the querey that requires a particular key's value to be
            a list containing all of the elements in the provided list of values.
            </summary>
            <param name="key">The key to check.</param>
            <param name="values">The values that will match.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereContains(System.String,System.String)">
            <summary>
            Adds a constraint for finding string values that contain a provided string.
            This will be slow for large data sets.
            </summary>
            <param name="key">The key that the string to match is stored in.</param>
            <param name="substring">The substring that the value must contain.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereDoesNotExist(System.String)">
            <summary>
            Adds a constraint for finding objects that do not contain a given key.
            </summary>
            <param name="key">The key that should not exist.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereDoesNotMatchQuery``1(System.String,Parse.ParseQuery{``0})">
            <summary>
            Adds a constraint to the query that requires that a particular key's value
            does not match another ParseQuery. This only works on keys whose values are
            ParseObjects or lists of ParseObjects.
            </summary>
            <param name="key">The key to check.</param>
            <param name="query">The query that the value should not match.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereEndsWith(System.String,System.String)">
            <summary>
            Adds a constraint for finding string values that end with a provided string.
            This will be slow for large data sets.
            </summary>
            <param name="key">The key that the string to match is stored in.</param>
            <param name="suffix">The substring that the value must end with.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereEqualTo(System.String,System.Object)">
            <summary>
            Adds a constraint to the query that requires a particular key's value to be
            equal to the provided value.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value that the ParseObject must contain.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereExists(System.String)">
            <summary>
            Adds a constraint for finding objects that contain a given key.
            </summary>
            <param name="key">The key that should exist.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereGreaterThan(System.String,System.Object)">
            <summary>
            Adds a constraint to the query that requires a particular key's value to be
            greater than the provided value.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value that provides a lower bound.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereGreaterThanOrEqualTo(System.String,System.Object)">
            <summary>
            Adds a constraint to the query that requires a particular key's value to be
            greater or equal to than the provided value.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value that provides a lower bound.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereLessThan(System.String,System.Object)">
            <summary>
            Adds a constraint to the query that requires a particular key's value to be
            less than the provided value.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value that provides an upper bound.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereLessThanOrEqualTo(System.String,System.Object)">
            <summary>
            Adds a constraint to the query that requires a particular key's value to be
            less than or equal to the provided value.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value that provides a lower bound.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereMatches(System.String,System.Text.RegularExpressions.Regex,System.String)">
            <summary>
            Adds a regular expression constraint for finding string values that match the provided
            regular expression. This may be slow for large data sets.
            </summary>
            <param name="key">The key that the string to match is stored in.</param>
            <param name="regex">The regular expression pattern to match. The Regex must
            have the <see cref="F:System.Text.RegularExpressions.RegexOptions.ECMAScript"/> options flag set.</param>
            <param name="modifiers">Any of the following supported PCRE modifiers:
            <code>i</code> - Case insensitive search
            <code>m</code> Search across multiple lines of input</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereMatches(System.String,System.Text.RegularExpressions.Regex)">
            <summary>
            Adds a regular expression constraint for finding string values that match the provided
            regular expression. This may be slow for large data sets.
            </summary>
            <param name="key">The key that the string to match is stored in.</param>
            <param name="regex">The regular expression pattern to match. The Regex must
            have the <see cref="F:System.Text.RegularExpressions.RegexOptions.ECMAScript"/> options flag set.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereMatches(System.String,System.String,System.String)">
            <summary>
            Adds a regular expression constraint for finding string values that match the provided
            regular expression. This may be slow for large data sets.
            </summary>
            <param name="key">The key that the string to match is stored in.</param>
            <param name="pattern">The PCRE regular expression pattern to match.</param>
            <param name="modifiers">Any of the following supported PCRE modifiers:
            <code>i</code> - Case insensitive search
            <code>m</code> Search across multiple lines of input</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereMatches(System.String,System.String)">
            <summary>
            Adds a regular expression constraint for finding string values that match the provided
            regular expression. This may be slow for large data sets.
            </summary>
            <param name="key">The key that the string to match is stored in.</param>
            <param name="pattern">The PCRE regular expression pattern to match.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereMatchesKeyInQuery``1(System.String,System.String,Parse.ParseQuery{``0})">
            <summary>
            Adds a constraint to the query that requires a particular key's value
            to match a value for a key in the results of another ParseQuery.
            </summary>
            <param name="key">The key whose value is being checked.</param>
            <param name="keyInQuery">The key in the objects from the subquery to look in.</param>
            <param name="query">The subquery to run</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereDoesNotMatchesKeyInQuery``1(System.String,System.String,Parse.ParseQuery{``0})">
            <summary>
            Adds a constraint to the query that requires a particular key's value
            does not match any value for a key in the results of another ParseQuery.
            </summary>
            <param name="key">The key whose value is being checked.</param>
            <param name="keyInQuery">The key in the objects from the subquery to look in.</param>
            <param name="query">The subquery to run</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereMatchesQuery``1(System.String,Parse.ParseQuery{``0})">
            <summary>
            Adds a constraint to the query that requires that a particular key's value
            matches another ParseQuery. This only works on keys whose values are
            ParseObjects or lists of ParseObjects.
            </summary>
            <param name="key">The key to check.</param>
            <param name="query">The query that the value should match.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereNear(System.String,Parse.ParseGeoPoint)">
            <summary>
            Adds a proximity-based constraint for finding objects with keys whose GeoPoint
            values are near the given point.
            </summary>
            <param name="key">The key that the ParseGeoPoint is stored in.</param>
            <param name="point">The reference ParseGeoPoint.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereNotContainedIn``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds a constraint to the query that requires a particular key's value to be
            contained in the provided list of values.
            </summary>
            <param name="key">The key to check.</param>
            <param name="values">The values that will match.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereNotEqualTo(System.String,System.Object)">
            <summary>
            Adds a constraint to the query that requires a particular key's value not
            to be equal to the provided value.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value that that must not be equalled.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereStartsWith(System.String,System.String)">
            <summary>
            Adds a constraint for finding string values that start with the provided string.
            This query will use the backend index, so it will be fast even with large data sets.
            </summary>
            <param name="key">The key that the string to match is stored in.</param>
            <param name="suffix">The substring that the value must start with.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereWithinGeoBox(System.String,Parse.ParseGeoPoint,Parse.ParseGeoPoint)">
            <summary>
            Add a constraint to the query that requires a particular key's coordinates to be
            contained within a given rectangular geographic bounding box.
            </summary>
            <param name="key">The key to be constrained.</param>
            <param name="southwest">The lower-left inclusive corner of the box.</param>
            <param name="northeast">The upper-right inclusive corner of the box.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereWithinDistance(System.String,Parse.ParseGeoPoint,Parse.ParseGeoDistance)">
            <summary>
            Adds a proximity-based constraint for finding objects with keys whose GeoPoint
            values are near the given point and within the maximum distance given.
            </summary>
            <param name="key">The key that the ParseGeoPoint is stored in.</param>
            <param name="point">The reference ParseGeoPoint.</param>
            <param name="maxDistance">The maximum distance (in radians) of results to return.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.FindAsync">
            <summary>
            Retrieves a list of ParseObjects that satisfy this query from Parse.
            </summary>
            <returns>The list of ParseObjects that match this query.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.FindAsync(System.Threading.CancellationToken)">
            <summary>
            Retrieves a list of ParseObjects that satisfy this query from Parse.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The list of ParseObjects that match this query.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.FirstOrDefaultAsync">
            <summary>
            Retrieves at most one ParseObject that satisfies this query.
            </summary>
            <returns>A single ParseObject that satisfies this query, or else null.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.FirstOrDefaultAsync(System.Threading.CancellationToken)">
            <summary>
            Retrieves at most one ParseObject that satisfies this query.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A single ParseObject that satisfies this query, or else null.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.FirstAsync">
            <summary>
            Retrieves at most one ParseObject that satisfies this query.
            </summary>
            <returns>A single ParseObject that satisfies this query.</returns>
            <exception cref="T:Parse.ParseException">If no results match the query.</exception>
        </member>
        <member name="M:Parse.ParseQuery`1.FirstAsync(System.Threading.CancellationToken)">
            <summary>
            Retrieves at most one ParseObject that satisfies this query.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A single ParseObject that satisfies this query.</returns>
            <exception cref="T:Parse.ParseException">If no results match the query.</exception>
        </member>
        <member name="M:Parse.ParseQuery`1.CountAsync">
            <summary>
            Counts the number of objects that match this query.
            </summary>
            <returns>The number of objects that match this query.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.CountAsync(System.Threading.CancellationToken)">
            <summary>
            Counts the number of objects that match this query.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The number of objects that match this query.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.GetAsync(System.String)">
            <summary>
            Constructs a ParseObject whose id is already known by fetching data
            from the server.
            </summary>
            <param name="objectId">ObjectId of the ParseObject to fetch.</param>
            <returns>The ParseObject for the given objectId.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.GetAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Constructs a ParseObject whose id is already known by fetching data
            from the server.
            </summary>
            <param name="objectId">ObjectId of the ParseObject to fetch.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The ParseObject for the given objectId.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to the current object.
            </summary>
            <param name="obj">The object to compare with the current object.</param>
            <returns><c>true</c> if the specified object is equal to the current object; otherwise, <c>false</c></returns>
        </member>
        <member name="M:Parse.ParseQuery`1.GetHashCode">
            <summary>
            Serves as the default hash function.
            </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="T:Parse.ParseRelationBase">
            <summary>
            A common base class for ParseRelations.
            </summary>
        </member>
        <member name="M:Parse.ParseRelationBase.CreateRelation(Parse.ParseObject,System.String,System.String)">
            <summary>
            Produces the proper ParseRelation&lt;T&gt; instance for the given classname.
            </summary>
        </member>
        <member name="T:Parse.ParseRelation`1">
            <summary>
            Provides access to all of the children of a many-to-many relationship. Each instance of
            ParseRelation is associated with a particular parent and key.
            </summary>
            <typeparam name="T">The type of the child objects.</typeparam>
        </member>
        <member name="M:Parse.ParseRelation`1.Add(`0)">
            <summary>
            Adds an object to this relation. The object must already have been saved.
            </summary>
            <param name="obj">The object to add.</param>
        </member>
        <member name="M:Parse.ParseRelation`1.Remove(`0)">
            <summary>
            Removes an object from this relation. The object must already have been saved.
            </summary>
            <param name="obj">The object to remove.</param>
        </member>
        <member name="P:Parse.ParseRelation`1.Query">
            <summary>
            Gets a query that can be used to query the objects in this relation.
            </summary>
        </member>
        <member name="T:Parse.ParseRole">
            <summary>
            Represents a Role on the Parse server. ParseRoles represent groupings
            of <see cref="T:Parse.ParseUser"/>s for the purposes of granting permissions (e.g.
            specifying a <see cref="T:Parse.ParseACL"/> for a <see cref="T:Parse.ParseObject"/>. Roles
            are specified by their sets of child users and child roles, all of which are granted
            any permissions that the parent role has.
            
            Roles must have a name (that cannot be changed after creation of the role),
            and must specify an ACL.
            </summary>
        </member>
        <member name="M:Parse.ParseRole.#ctor">
            <summary>
            Constructs a new ParseRole. You must assign a name and ACL to the role.
            </summary>
        </member>
        <member name="M:Parse.ParseRole.#ctor(System.String,Parse.ParseACL)">
            <summary>
            Constructs a new ParseRole with the given name.
            </summary>
            <param name="name">The name of the role to create.</param>
            <param name="acl">The ACL for this role. Roles must have an ACL.</param>
        </member>
        <member name="P:Parse.ParseRole.Name">
            <summary>
            Gets the name of the role.
            </summary>
        </member>
        <member name="P:Parse.ParseRole.Users">
            <summary>
            Gets the <see cref="T:Parse.ParseRelation`1"/> for the <see cref="T:Parse.ParseUser"/>s that are
            direct children of this role. These users are granted any privileges that
            this role has been granted (e.g. read or write access through ACLs). You can
            add or remove child users from the role through this relation.
            </summary>
        </member>
        <member name="P:Parse.ParseRole.Roles">
            <summary>
            Gets the <see cref="T:Parse.ParseRelation`1"/> for the <see cref="T:Parse.ParseRole"/>s that are
            direct children of this role. These roles' users are granted any privileges that
            this role has been granted (e.g. read or write access through ACLs). You can
            add or remove child roles from the role through this relation.
            </summary>
        </member>
        <member name="P:Parse.ParseRole.Query">
            <summary>
            Gets a <see cref="T:Parse.ParseQuery`1"/> over the Role collection.
            </summary>
        </member>
        <member name="T:Parse.ParseSession">
            <summary>
            Represents a session of a user for a Parse application.
            </summary>
        </member>
        <member name="M:Parse.ParseSession.GetCurrentSessionAsync">
            <summary>
            Gets the current <see cref="T:Parse.ParseSession"/> object related to the current user.
            </summary>
        </member>
        <member name="M:Parse.ParseSession.GetCurrentSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the current <see cref="T:Parse.ParseSession"/> object related to the current user.
            </summary>
            <param name="cancellationToken">The cancellation token</param>
        </member>
        <member name="P:Parse.ParseSession.SessionToken">
            <summary>
            Gets the session token for a user, if they are logged in.
            </summary>
        </member>
        <member name="P:Parse.ParseSession.Query">
            <summary>
            Constructs a <see cref="T:Parse.ParseQuery`1"/> for ParseSession.
            </summary>
        </member>
        <member name="T:Parse.ParseUploadProgressEventArgs">
            <summary>
            Represents upload progress.
            </summary>
        </member>
        <member name="P:Parse.ParseUploadProgressEventArgs.Progress">
            <summary>
            Gets the progress (a number between 0.0 and 1.0) of an upload.
            </summary>
        </member>
        <member name="T:Parse.ParseUser">
            <summary>
            Represents a user for a Parse application.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.Remove(System.String)">
            <summary>
            Removes a key from the object's data if it exists.
            </summary>
            <param name="key">The key to remove.</param>
            <exception cref="T:System.ArgumentException">Cannot remove the username key.</exception>
        </member>
        <member name="M:Parse.ParseUser.SignUpAsync">
            <summary>
            Signs up a new user. This will create a new ParseUser on the server and will also persist the
            session on disk so that you can access the user using <see cref="P:Parse.ParseUser.CurrentUser"/>. A username and
            password must be set before calling SignUpAsync.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.SignUpAsync(System.Threading.CancellationToken)">
            <summary>
            Signs up a new user. This will create a new ParseUser on the server and will also persist the
            session on disk so that you can access the user using <see cref="P:Parse.ParseUser.CurrentUser"/>. A username and
            password must be set before calling SignUpAsync.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseUser.LogInAsync(System.String,System.String)">
            <summary>
            Logs in a user with a username and password. On success, this saves the session to disk so you
            can retrieve the currently logged in user using <see cref="P:Parse.ParseUser.CurrentUser"/>.
            </summary>
            <param name="username">The username to log in with.</param>
            <param name="password">The password to log in with.</param>
            <returns>The newly logged-in user.</returns>
        </member>
        <member name="M:Parse.ParseUser.LogInAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Logs in a user with a username and password. On success, this saves the session to disk so you
            can retrieve the currently logged in user using <see cref="P:Parse.ParseUser.CurrentUser"/>.
            </summary>
            <param name="username">The username to log in with.</param>
            <param name="password">The password to log in with.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The newly logged-in user.</returns>
        </member>
        <member name="M:Parse.ParseUser.BecomeAsync(System.String)">
            <summary>
            Logs in a user with a username and password. On success, this saves the session to disk so you
            can retrieve the currently logged in user using <see cref="P:Parse.ParseUser.CurrentUser"/>.
            </summary>
            <param name="sessionToken">The session token to authorize with</param>
            <returns>The user if authorization was successful</returns>
        </member>
        <member name="M:Parse.ParseUser.BecomeAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Logs in a user with a username and password. On success, this saves the session to disk so you
            can retrieve the currently logged in user using <see cref="P:Parse.ParseUser.CurrentUser"/>.
            </summary>
            <param name="sessionToken">The session token to authorize with</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The user if authorization was successful</returns>
        </member>
        <member name="M:Parse.ParseUser.LogOut">
            <summary>
            Logs out the currently logged in user session. This will remove the session from disk, log out of
            linked services, and future calls to <see cref="P:Parse.ParseUser.CurrentUser"/> will return <c>null</c>.
            </summary>
            <remarks>
            Typically, you should use <see cref="M:Parse.ParseUser.LogOutAsync"/>, unless you are managing your own threading.
            </remarks>
        </member>
        <member name="M:Parse.ParseUser.LogOutAsync">
            <summary>
            Logs out the currently logged in user session. This will remove the session from disk, log out of
            linked services, and future calls to <see cref="P:Parse.ParseUser.CurrentUser"/> will return <c>null</c>.
            </summary>
            <remarks>
            This is preferable to using <see cref="M:Parse.ParseUser.LogOut"/>, unless your code is already running from a
            background thread.
            </remarks>
        </member>
        <member name="M:Parse.ParseUser.LogOutAsync(System.Threading.CancellationToken)">
            <summary>
            Logs out the currently logged in user session. This will remove the session from disk, log out of
            linked services, and future calls to <see cref="P:Parse.ParseUser.CurrentUser"/> will return <c>null</c>.
            
            This is preferable to using <see cref="M:Parse.ParseUser.LogOut"/>, unless your code is already running from a
            background thread.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.GetCurrentUserAsync">
            <summary>
            Gets the currently logged in ParseUser with a valid session, either from memory or disk
            if necessary, asynchronously.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.GetCurrentUserAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the currently logged in ParseUser with a valid session, either from memory or disk
            if necessary, asynchronously.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.EnableRevocableSessionAsync">
            <summary>
            Tells server to use revocable session on LogIn and SignUp, even when App's Settings
            has "Require Revocable Session" turned off. Issues network request in background to
            migrate the sessionToken on disk to revocable session.
            </summary>
            <returns>The Task that upgrades the session.</returns>
        </member>
        <member name="M:Parse.ParseUser.EnableRevocableSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Tells server to use revocable session on LogIn and SignUp, even when App's Settings
            has "Require Revocable Session" turned off. Issues network request in background to
            migrate the sessionToken on disk to revocable session.
            </summary>
            <returns>The Task that upgrades the session.</returns>
        </member>
        <member name="M:Parse.ParseUser.RequestPasswordResetAsync(System.String)">
            <summary>
            Requests a password reset email to be sent to the specified email address associated with the
            user account. This email allows the user to securely reset their password on the Parse site.
            </summary>
            <param name="email">The email address associated with the user that forgot their password.</param>
        </member>
        <member name="M:Parse.ParseUser.RequestPasswordResetAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Requests a password reset email to be sent to the specified email address associated with the
            user account. This email allows the user to securely reset their password on the Parse site.
            </summary>
            <param name="email">The email address associated with the user that forgot their password.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseUser.CleanupAuthData">
            <summary>
            Removes null values from authData (which exist temporarily for unlinking)
            </summary>
        </member>
        <member name="M:Parse.ParseUser.SynchronizeAllAuthData">
            <summary>
            Synchronizes authData for all providers.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.UnlinkFromAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Unlinks a user from a service.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.IsLinked(System.String)">
            <summary>
            Checks whether a user is linked to a service.
            </summary>
        </member>
        <member name="P:Parse.ParseUser.IsAuthenticated">
            <summary>
            Whether the ParseUser has been authenticated on this device. Only an authenticated
            ParseUser can be saved and deleted.
            </summary>
        </member>
        <member name="P:Parse.ParseUser.Username">
            <summary>
            Gets or sets the username.
            </summary>
        </member>
        <member name="P:Parse.ParseUser.Password">
            <summary>
            Sets the password.
            </summary>
        </member>
        <member name="P:Parse.ParseUser.Email">
            <summary>
            Sets the email address.
            </summary>
        </member>
        <member name="P:Parse.ParseUser.CurrentUser">
            <summary>
            Gets the currently logged in ParseUser with a valid session, either from memory or disk
            if necessary.
            </summary>
        </member>
        <member name="P:Parse.ParseUser.Query">
            <summary>
            Constructs a <see cref="T:Parse.ParseQuery`1"/> for ParseUsers.
            </summary>
        </member>
        <member name="P:Parse.ParseUser.AuthData">
            <summary>
            Gets the authData for this user.
            </summary>
        </member>
        <member name="T:Parse.ParseAnalytics">
            <summary>
            Provides an interface to Parse's logging and analytics backend.
            
            Methods will return immediately and cache requests (along with timestamps)
            to be handled in the background. 
            </summary>
        </member>
        <member name="M:Parse.ParseAnalytics.TrackAppOpenedAsync">
            <summary>
            Tracks this application being launched.
            </summary>
            <returns>An Async Task that can be waited on or ignored.</returns>
        </member>
        <member name="M:Parse.ParseAnalytics.TrackEventAsync(System.String)">
             <summary>
             Tracks the occurrence of a custom event with additional dimensions.
             Parse will store a data point at the time of invocation with the
             given event name.
            
             Dimensions will allow segmentation of the occurrences of this
             custom event.
            
             To track a user signup along with additional metadata, consider the
             following:
             <code>
             IDictionary&lt;string, string&gt; dims = new Dictionary&lt;string, string&gt; {
               { "gender", "m" },
               { "source", "web" },
               { "dayType", "weekend" }
             };
             ParseAnalytics.TrackEventAsync("signup", dims);
             </code>
            
             There is a default limit of 8 dimensions per event tracked.
             </summary>
             <param name="name">The name of the custom event to report to ParseClient
             as having happened.</param>
             <returns>An Async Task that can be waited on or ignored.</returns>
        </member>
        <member name="M:Parse.ParseAnalytics.TrackEventAsync(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
             <summary>
             Tracks the occurrence of a custom event with additional dimensions.
             Parse will store a data point at the time of invocation with the
             given event name.
            
             Dimensions will allow segmentation of the occurrences of this
             custom event.
            
             To track a user signup along with additional metadata, consider the
             following:
             <code>
             IDictionary&lt;string, string&gt; dims = new Dictionary&lt;string, string&gt; {
               { "gender", "m" },
               { "source", "web" },
               { "dayType", "weekend" }
             };
             ParseAnalytics.TrackEventAsync("signup", dims);
             </code>
            
             There is a default limit of 8 dimensions per event tracked.
             </summary>
             <param name="name">The name of the custom event to report to ParseClient
             as having happened.</param>
             <param name="dimensions">The dictionary of information by which to
             segment this event.</param>
             <returns>An Async Task that can be waited on or ignored.</returns>
        </member>
        <member name="M:Parse.ParseAnalytics.TrackAppOpenedWithPushHashAsync(System.String)">
            <summary>
            Private method, used by platform-specific extensions to report an app-open
            to the server.
            </summary>
            <param name="pushHash">An identifying hash for a given push notification,
            passed down from the server.</param>
            <returns>An Async Task that can be waited on or ignored.</returns>
        </member>
        <member name="T:Parse.ParseFacebookUtils">
            <summary>
            Provides a set of utilities for using Parse with Facebook.
            </summary>
        </member>
        <member name="M:Parse.ParseFacebookUtils.Initialize">
            <summary>
            Unity will just auto-initialize this. Since we're not responsible for login, we don't
            need the application id -- just the tokens.
            </summary>
        </member>
        <member name="M:Parse.ParseFacebookUtils.LogInAsync(System.String,System.String,System.DateTime,System.Threading.CancellationToken)">
            <summary>
            Logs in a <see cref="T:Parse.ParseUser"/> using Facebook for authentication. If a user for the
            given Facebook credentials does not already exist, a new user will be created.
            </summary>
            <param name="facebookId">The user's Facebook ID.</param>
            <param name="accessToken">A valid access token for the user.</param>
            <param name="expiration">The expiration date of the access token.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The user that was either logged in or created.</returns>
        </member>
        <member name="M:Parse.ParseFacebookUtils.LogInAsync(System.String,System.String,System.DateTime)">
            <summary>
            Logs in a <see cref="T:Parse.ParseUser"/> using Facebook for authentication. If a user for the
            given Facebook credentials does not already exist, a new user will be created.
            </summary>
            <param name="facebookId">The user's Facebook ID.</param>
            <param name="accessToken">A valid access token for the user.</param>
            <param name="expiration">The expiration date of the access token.</param>
            <returns>The user that was either logged in or created.</returns>
        </member>
        <member name="M:Parse.ParseFacebookUtils.LinkAsync(Parse.ParseUser,System.String,System.String,System.DateTime,System.Threading.CancellationToken)">
            <summary>
            Links a <see cref="T:Parse.ParseUser"/> to a Facebook account, allowing you to use Facebook
            for authentication, and providing access to Facebook data for the user.
            </summary>
            <param name="user">The user to link to a Facebook account.</param>
            <param name="facebookId">The user's Facebook ID.</param>
            <param name="accessToken">A valid access token for the user.</param>
            <param name="expiration">The expiration date of the access token.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseFacebookUtils.LinkAsync(Parse.ParseUser,System.String,System.String,System.DateTime)">
            <summary>
            Links a <see cref="T:Parse.ParseUser"/> to a Facebook account, allowing you to use Facebook
            for authentication, and providing access to Facebook data for the user.
            </summary>
            <param name="user">The user to link to a Facebook account.</param>
            <param name="facebookId">The user's Facebook ID.</param>
            <param name="accessToken">A valid access token for the user.</param>
            <param name="expiration">The expiration date of the access token.</param>
        </member>
        <member name="M:Parse.ParseFacebookUtils.IsLinked(Parse.ParseUser)">
            <summary>
            Gets whether the given user is linked to a Facebook account. This can only be used on
            the currently authorized user.
            </summary>
            <param name="user">The user to check.</param>
            <returns><c>true</c> if the user is linked to a Facebook account.</returns>
        </member>
        <member name="M:Parse.ParseFacebookUtils.UnlinkAsync(Parse.ParseUser,System.Threading.CancellationToken)">
            <summary>
            Unlinks a user from a Facebook account. Unlinking a user will save the user's data.
            </summary>
            <param name="user">The user to unlink.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseFacebookUtils.UnlinkAsync(Parse.ParseUser)">
            <summary>
            Unlinks a user from a Facebook account. Unlinking a user will save the user's data.
            </summary>
            <param name="user">The user to unlink.</param>
        </member>
        <member name="P:Parse.ParseFacebookUtils.AccessToken">
            <summary>
            Gets the access token for the currently logged in Facebook user. This can be used with a
            Facebook SDK to get access to Facebook user data.
            </summary>
        </member>
        <member name="T:Parse.ParsePush">
            <summary>
             A utility class for sending and receiving push notifications.
            </summary>
        </member>
        <member name="M:Parse.ParsePush.#ctor">
            <summary>
            Creates a push which will target every device. The Data field must be set before calling SendAsync.
            </summary>
        </member>
        <member name="M:Parse.ParsePush.SendAsync">
            <summary>
            Request a push to be sent. When this task completes, Parse has successfully acknowledged a request
            to send push notifications but has not necessarily finished sending all notifications
            requested. The current status of recent push notifications can be seen in your Push Notifications
            console on http://parse.com
            </summary>
            <returns>A Task for continuation.</returns>
        </member>
        <member name="M:Parse.ParsePush.SendAsync(System.Threading.CancellationToken)">
            <summary>
            Request a push to be sent. When this task completes, Parse has successfully acknowledged a request
            to send push notifications but has not necessarily finished sending all notifications
            requested. The current status of recent push notifications can be seen in your Push Notifications
            console on http://parse.com
            </summary>
            <param name="cancellationToken">CancellationToken to cancel the current operation.</param>
        </member>
        <member name="M:Parse.ParsePush.SendAlertAsync(System.String)">
             <summary>
             Pushes a simple message to every device. This is shorthand for:
            
             <code>
             var push = new ParsePush();
             push.Data = new Dictionary&lt;string, object&gt;{{"alert", alert}};
             return push.SendAsync();
             </code>
             </summary>
             <param name="alert">The alert message to send.</param>
        </member>
        <member name="M:Parse.ParsePush.SendAlertAsync(System.String,System.String)">
             <summary>
             Pushes a simple message to every device subscribed to channel. This is shorthand for:
            
             <code>
             var push = new ParsePush();
             push.Channels = new List&lt;string&gt; { channel };
             push.Data = new Dictionary&lt;string, object&gt;{{"alert", alert}};
             return push.SendAsync();
             </code>
             </summary>
             <param name="alert">The alert message to send.</param>
             <param name="channel">An Installation must be subscribed to channel to receive this Push Notification.</param>
        </member>
        <member name="M:Parse.ParsePush.SendAlertAsync(System.String,System.Collections.Generic.IEnumerable{System.String})">
             <summary>
             Pushes a simple message to every device subscribed to any of channels. This is shorthand for:
            
             <code>
             var push = new ParsePush();
             push.Channels = channels;
             push.Data = new Dictionary&lt;string, object&gt;{{"alert", alert}};
             return push.SendAsync();
             </code>
             </summary>
             <param name="alert">The alert message to send.</param>
             <param name="channels">An Installation must be subscribed to any of channels to receive this Push Notification.</param>
        </member>
        <member name="M:Parse.ParsePush.SendAlertAsync(System.String,Parse.ParseQuery{Parse.ParseInstallation})">
             <summary>
             Pushes a simple message to every device matching the target query. This is shorthand for:
            
             <code>
             var push = new ParsePush();
             push.Query = query;
             push.Data = new Dictionary&lt;string, object&gt;{{"alert", alert}};
             return push.SendAsync();
             </code>
             </summary>
             <param name="alert">The alert message to send.</param>
             <param name="query">A query filtering the devices which should receive this Push Notification.</param>
        </member>
        <member name="M:Parse.ParsePush.SendDataAsync(System.Collections.Generic.IDictionary{System.String,System.Object})">
             <summary>
             Pushes an arbitrary payload to every device. This is shorthand for:
            
             <code>
             var push = new ParsePush();
             push.Data = data;
             return push.SendAsync();
             </code>
             </summary>
             <param name="data">A push payload. See the ParsePush.Data property for more information.</param>
        </member>
        <member name="M:Parse.ParsePush.SendDataAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.String)">
             <summary>
             Pushes an arbitrary payload to every device subscribed to channel. This is shorthand for:
            
             <code>
             var push = new ParsePush();
             push.Channels = new List&lt;string&gt; { channel };
             push.Data = data;
             return push.SendAsync();
             </code>
             </summary>
             <param name="data">A push payload. See the ParsePush.Data property for more information.</param>
             <param name="channel">An Installation must be subscribed to channel to receive this Push Notification.</param>
        </member>
        <member name="M:Parse.ParsePush.SendDataAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IEnumerable{System.String})">
             <summary>
             Pushes an arbitrary payload to every device subscribed to any of channels. This is shorthand for:
            
             <code>
             var push = new ParsePush();
             push.Channels = channels;
             push.Data = data;
             return push.SendAsync();
             </code>
             </summary>
             <param name="data">A push payload. See the ParsePush.Data property for more information.</param>
             <param name="channels">An Installation must be subscribed to any of channels to receive this Push Notification.</param>
        </member>
        <member name="M:Parse.ParsePush.SendDataAsync(System.Collections.Generic.IDictionary{System.String,System.Object},Parse.ParseQuery{Parse.ParseInstallation})">
             <summary>
             Pushes an arbitrary payload to every device matching target. This is shorthand for:
            
             <code>
             var push = new ParsePush();
             push.Query = query
             push.Data = data;
             return push.SendAsync();
             </code>
             </summary>
             <param name="data">A push payload. See the ParsePush.Data property for more information.</param>
             <param name="query">A query filtering the devices which should receive this Push Notification.</param>
        </member>
        <member name="M:Parse.ParsePush.SubscribeAsync(System.String)">
             <summary>
             Subscribe the current installation to this channel. This is shorthand for:
            
             <code>
             var installation = ParseInstallation.CurrentInstallation;
             installation.AddUniqueToList("channels", channel);
             installation.SaveAsync();
             </code>
             </summary>
             <param name="channel">The channel to which this installation should subscribe.</param>
        </member>
        <member name="M:Parse.ParsePush.SubscribeAsync(System.String,System.Threading.CancellationToken)">
             <summary>
             Subscribe the current installation to this channel. This is shorthand for:
            
             <code>
             var installation = ParseInstallation.CurrentInstallation;
             installation.AddUniqueToList("channels", channel);
             installation.SaveAsync(cancellationToken);
             </code>
             </summary>
             <param name="channel">The channel to which this installation should subscribe.</param>
             <param name="cancellationToken">CancellationToken to cancel the current operation.</param>
        </member>
        <member name="M:Parse.ParsePush.SubscribeAsync(System.Collections.Generic.IEnumerable{System.String})">
             <summary>
             Subscribe the current installation to these channels. This is shorthand for:
            
             <code>
             var installation = ParseInstallation.CurrentInstallation;
             installation.AddRangeUniqueToList("channels", channels);
             installation.SaveAsync();
             </code>
             </summary>
             <param name="channels">The channels to which this installation should subscribe.</param>
        </member>
        <member name="M:Parse.ParsePush.SubscribeAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
             <summary>
             Subscribe the current installation to these channels. This is shorthand for:
            
             <code>
             var installation = ParseInstallation.CurrentInstallation;
             installation.AddRangeUniqueToList("channels", channels);
             installation.SaveAsync(cancellationToken);
             </code>
             </summary>
             <param name="channels">The channels to which this installation should subscribe.</param>
             <param name="cancellationToken">CancellationToken to cancel the current operation.</param>
        </member>
        <member name="M:Parse.ParsePush.UnsubscribeAsync(System.String)">
             <summary>
             Unsubscribe the current installation from this channel. This is shorthand for:
            
             <code>
             var installation = ParseInstallation.CurrentInstallation;
             installation.Remove("channels", channel);
             installation.SaveAsync();
             </code>
             </summary>
             <param name="channel">The channel from which this installation should unsubscribe.</param>
        </member>
        <member name="M:Parse.ParsePush.UnsubscribeAsync(System.String,System.Threading.CancellationToken)">
             <summary>
             Unsubscribe the current installation from this channel. This is shorthand for:
            
             <code>
             var installation = ParseInstallation.CurrentInstallation;
             installation.Remove("channels", channel);
             installation.SaveAsync(cancellationToken);
             </code>
             </summary>
             <param name="channel">The channel from which this installation should unsubscribe.</param>
             <param name="cancellationToken">CancellationToken to cancel the current operation.</param>
        </member>
        <member name="M:Parse.ParsePush.UnsubscribeAsync(System.Collections.Generic.IEnumerable{System.String})">
             <summary>
             Unsubscribe the current installation from these channels. This is shorthand for:
            
             <code>
             var installation = ParseInstallation.CurrentInstallation;
             installation.RemoveAllFromList("channels", channels);
             installation.SaveAsync();
             </code>
             </summary>
             <param name="channels">The channels from which this installation should unsubscribe.</param>
        </member>
        <member name="M:Parse.ParsePush.UnsubscribeAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
             <summary>
             Unsubscribe the current installation from these channels. This is shorthand for:
            
             <code>
             var installation = ParseInstallation.CurrentInstallation;
             installation.RemoveAllFromList("channels", channels);
             installation.SaveAsync(cancellationToken);
             </code>
             </summary>
             <param name="channels">The channels from which this installation should unsubscribe.</param>
             <param name="cancellationToken">CancellationToken to cancel the current operation.</param>
        </member>
        <member name="P:Parse.ParsePush.Query">
            <summary>
            An installation query that specifies which installations should receive
            this push.
            This should not be used in tandem with Channels.
            </summary>
        </member>
        <member name="P:Parse.ParsePush.Channels">
             <summary>
             A short-hand to set a query which only discriminates on the channels to which a device is subscribed.
             This is shorthand for:
            
             <code>
             var push = new Push();
             push.Query = ParseInstallation.Query.WhereKeyContainedIn("channels", channels);
             </code>
            
             This cannot be used in tandem with Query.
             </summary>
        </member>
        <member name="P:Parse.ParsePush.Expiration">
            <summary>
            The time at which this push will expire. This should not be used in tandem with ExpirationInterval.
            </summary>
        </member>
        <member name="P:Parse.ParsePush.PushTime">
            <summary>
            The time at which this push will be sent.
            </summary>
        </member>
        <member name="P:Parse.ParsePush.ExpirationInterval">
            <summary>
            The time from initial schedul when this push will expire. This should not be used in tandem with Expiration.
            </summary>
        </member>
        <member name="P:Parse.ParsePush.Data">
            <summary>
            The contents of this push. Some keys have special meaning. A full list of pre-defined
            keys can be found in the Parse Push Guide. The following keys affect WinRT devices.
            Keys which do not start with x-winrt- can be prefixed with x-winrt- to specify an
            override only sent to winrt devices.
            alert: the body of the alert text.
            title: The title of the text.
            x-winrt-payload: A full XML payload to be sent to WinRT installations instead of
                 the auto-layout.
            This should not be used in tandem with Alert.
            </summary>
        </member>
        <member name="P:Parse.ParsePush.Alert">
             <summary>
             A convenience method which sets Data to a dictionary with alert as its only field. Equivalent to
            
             <code>
             Data = new Dictionary&lt;string, object&gt; {{"alert", alert}};
             </code>
            
             This should not be used in tandem with Data.
             </summary>
        </member>
        <member name="E:Parse.ParsePush.ParsePushNotificationReceived">
            <summary>
            An event fired when a push notification is received.
            </summary>
        </member>
        <member name="T:Parse.ParseInitializeBehaviour">
            <summary>
            Mandatory MonoBehaviour for scenes that use Parse. Set the application ID and .NET key
            in the editor.
            </summary>
        </member>
        <member name="F:Parse.ParseInitializeBehaviour.applicationID">
            <summary>
            The Parse applicationId used in this app. You can get this value from the Parse website.
            </summary>
        </member>
        <member name="F:Parse.ParseInitializeBehaviour.dotnetKey">
            <summary>
            The Parse dotnetKey used in this app. You can get this value from the Parse website.
            </summary>
        </member>
        <member name="M:Parse.ParseInitializeBehaviour.Awake">
            <summary>
            Initializes the Parse SDK and begins running network requests created by Parse.
            </summary>
        </member>
        <member name="M:Parse.ParseInitializeBehaviour.OnApplicationPause(System.Boolean)">
            <summary>
            Delegate function that will be called when the player pauses the game.
            </summary>
            <seealso href="http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnApplicationPause.html"/>
            <param name="paused"><c>true</c> if the application is paused.</param>
        </member>
        <member name="M:Parse.ParseInitializeBehaviour.OnPushNotificationReceived(System.String)">
            <summary>
            The callback that will be called from the Android Java land via <c>UnityPlayer.UnitySendMessage(string)</c>
            when the device receive a push notification.
            </summary>
            <param name="pushPayloadString">the push payload as string</param>
        </member>
        <member name="M:Parse.ParseInitializeBehaviour.OnGcmRegistrationReceived(System.String)">
            <summary>
            The callback that will be called from the Android Java land via <c>UnityPlayer.UnitySendMessage(string)</c>
            when the device receive a GCM registration id.
            </summary>
            <param name="registrationId">the GCM registration id</param>
        </member>
        <member name="T:Parse.Utilities.Conversion">
            <summary>
            A set of utilities for converting generic types between each other.
            </summary>
        </member>
        <member name="M:Parse.Utilities.Conversion.As``1(System.Object)">
             <summary>
             Converts a value to the requested type -- coercing primitives to
             the desired type, wrapping lists and dictionaries appropriately,
             or else returning null.
            
             This should be used on any containers that might be coming from a
             user to normalize the collection types. Collection types coming from
             JSON deserialization can be safely assumed to be lists or dictionaries of
             objects.
             </summary>
        </member>
        <member name="M:Parse.Utilities.Conversion.To``1(System.Object)">
             <summary>
             Converts a value to the requested type -- coercing primitives to
             the desired type, wrapping lists and dictionaries appropriately,
             or else throwing an exception.
            
             This should be used on any containers that might be coming from a
             user to normalize the collection types. Collection types coming from
             JSON deserialization can be safely assumed to be lists or dictionaries of
             objects.
             </summary>
        </member>
        <member name="M:Parse.Utilities.Conversion.ConvertTo``1(System.Object)">
             <summary>
             Converts a value to the requested type -- coercing primitives to
             the desired type, wrapping lists and dictionaries appropriately,
             or else passing the object along to the caller unchanged.
            
             This should be used on any containers that might be coming from a
             user to normalize the collection types. Collection types coming from
             JSON deserialization can be safely assumed to be lists or dictionaries of
             objects.
             </summary>
        </member>
        <member name="F:Parse.Utilities.Conversion.interfaceLookupCache">
             <summary>
             Holds a dictionary that maps a cache of interface types for related concrete types.
             The lookup is slow the first time for each type because it has to enumerate all interface
             on the object type, but made fast by the cache.
            
             The map is:
                (object type, generic interface type) => constructed generic type
             </summary>
        </member>
    </members>
</doc>
